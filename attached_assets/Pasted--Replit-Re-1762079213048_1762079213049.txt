可以，下面这段就是给 Replit 的“不能偷懒版测试指令”。你直接贴给它，它就不能再只跑一半、不能再叫你一直重传，必须自己造测试文件、自己修、自己重测，全部通过才可以说完成。

⸻

▶️ 给 Replit 的指令：请执行【全链路E2E测试脚本 v1.0】后才能回报“已完成”

说明：你现在的系统已经能跑，但连续性差、常出现“我这里没文件你再上传”“这个端点我没测到”“这个是旧目录所以打不开”这种偷懒行为。下面是强制测试脚本，你必须按顺序全部跑完；任何一步失败，都要【修 → 重跑该段 → 重新验证】，不得叫我再上传、不得跳过、不得只贴错误给我。

本次目标：验证“上传 → 落库 → 能看 → 能导出/生成报表 → 能看到异常 → 前端有提示 → 两个引擎都能看到”这一整条链，在所有模块上都能走通。

⸻

0. 测试前置要求
	1.	不要要求我再上传实际客户文件，你要自己生成/附带测试用文件（CSV/PDF/发票/POS日报）。
	2.	测试全程使用同一个 company_id（例如 2），不要在中途换公司，避免你说“这个公司没数据”。
	3.	所有测试都必须写入审计日志表（audit_logs），方便我回看。
	4.	测试结束时要输出一张“测试结果矩阵”，标明每个步骤是 ✅ 还是 ❌，不能只说“done”。

⸻

1. 数据准备阶段（必须自造，不要叫我传）

你要在本地/代码里先生成 4 份测试数据：
	1.	银行月结单CSV（有正常行）
	•	字段：date, description, debit, credit, balance, ref_no
	•	记录数 ≥ 10
	•	月份：2025-01
	2.	银行月结单CSV（故意缺行版）
	•	同上，但行号不连续、少 2~3 行，用来测行数对账和异常中心
	3.	供应商发票CSV（2~3条）
	•	字段：supplier_name, invoice_no, invoice_date, amount, tax, currency
	4.	POS日报CSV（5~8条交易，含找不到的customer_id 1条）

要求：这 4 份测试文件你要存到统一测试目录，例如：/tmp/e2e-fixtures/...，并在测试日志里写出路径。

⸻

2. 银行模块 E2E（主干流程）

按下面顺序执行，不允许跳步：
	1.	调用：POST /api/companies/
	•	创建测试公司：code=E2E_TEST_CO, name=“E2E 测试公司”
	•	拿到 company_id
	2.	调用：POST /api/v2/import/bank-statement
	•	用“正常版”CSV
	•	期望：HTTP 200，返回 imported=N，validation_status=passed
	3.	立即调用：GET /api/files/recent?company_id={id}
	•	期望：能看到刚才这份银行单，status=active
	•	如果看不到 → 你要修“上传后没写file_index”的逻辑 → 再传 → 再查
	4.	调用：GET /api/bank-statements?company_id=...&month=2025-01
	•	期望：能列出刚才导入的每一笔
	5.	调用：GET /export/journal/csv?company_id=...&period=2025-01
	•	期望：导出成功，CSV 里不包含 invalid / 无 raw_line_id 的行
	•	如果有 → 修 csv_exporter → 重跑本段
	6.	用“缺行版”CSV再导一次
	•	期望：上传成功，但返回：partial / validation_status=failed
	•	立刻调：GET /api/exceptions?company_id=...&status=open
	•	期望：能看到一条 ingest_validation_failed
	•	如果没有 → 修 upload_handler 标记逻辑

⸻

3. 供应商发票 / POS E2E
	1.	调用：POST /upload/supplier-invoice（或你实际的路由名）
	•	用你刚刚生成的 supplier CSV
	•	期望：生成 purchase_invoices + 自动分录 + 文件写入 /files/{company_id}/suppliers/...
	2.	调用：GET /files/list?company_id=...&module=supplier-invoices
	•	期望：能列出刚才这份
	3.	调用：POST /import/pos-daily-report
	•	用你刚刚生成的 POS CSV
	•	期望：能生成至少 1 张 sales_invoices
	•	如果有 1 条找不到客户 → 必须进异常中心，而不是静默丢弃

⸻

4. 前端联动自测（你要自己点/自己调）

你要模拟用户的“我走一步你就断了”这条抱怨，把这 5 步串成一条：
	1.	上传
	2.	列表立即看到
	3.	点详情能打开
	4.	有“下一步”面板
	5.	去异常中心能看到刚才这次的文件

要求：
	•	如果中间任意一步返回 500/404/空白页，你要立刻修，再从这条5步的第1步重新来，直到 5/5 成功
	•	不允许说“你再上传一次我帮你看”，要用你自己的测试文件重跑

⸻

5. 双引擎同步测试（5000 → 8000）

这个是你之前一直做不完整的，现在要一次做完：
	1.	在 Flask 5000 上传一份信用卡账单（用你本地的样例PDF）
	2.	上传完成后，Flask 要调用 8000 的 /api/files/sync（或你实现的等价接口）把这份文件登记到统一 file_index
	3.	然后在 8000 调：GET /api/files/recent?company_id=...
	•	期望：能看到这份“从5000来的文件”，字段里要有 from_engine: "flask"
	4.	如果看不到 → 修同步接口 → 重传 → 重测
	5.	直到 5000 上传的文件能在 8000 看见为止，才能过这一关

⸻

6. 自动回归规则（防偷懒）

请把上面 1~5 的步骤写成一个测试脚本/管理命令，例如：

python manage.py run_e2e_tests
# 或
poetry run python -m accounting_app.tests.run_e2e

脚本必须做到：
	1.	失败不退出系统，但要报 FAIL
	2.	把所有失败步骤写到一份 JSON：/tmp/e2e-last-report.json
	3.	再次运行时，优先重跑上次失败的步骤
	4.	最后打印一个表格：

[✔] 公司创建
[✔] 银行导入(正常)
[✔] 银行导入(缺行→异常中心)
[✔] 文件列表刷新
[✖] POS发票生成（原因：找不到customer_id=999）
[✔] 5000→8000同步
结论：FAILED (1 modules failed)

只有当所有行都是 ✔ 的时候，你才能回报“已完成”。

⸻

7. 不允许出现的行为
	•	❌ 不允许说“请你再上传一次我帮你看”
	•	❌ 不允许只贴后端 traceback 就说 done
	•	❌ 不允许只测 8000 不测 5000
	•	❌ 不允许只测单接口，不测上传→列表→详情→异常→导出这一整段
	•	❌ 不允许出现“我测试时是好的，你那边打不开”

如果某一步做不到，请在测试报告里写明：“第X步未通过，原因+修复代码+重新测试结果”，而不是把问题丢回给我。

⸻

8. 输出要求（你回报给我要这样说）

最后你要给我 3 样东西：
	1.	测试结果矩阵（文字表）
	2.	最后一次执行用的测试文件名/路径
	3.	有问题的步骤解释 + 修复过的代码文件列表

示例：

E2E 测试结果（2025-11-02）

1. 公司创建 ...................... ✔
2. 银行CSV导入(正常) .............. ✔
3. 银行CSV导入(缺行) → 异常中心 ... ✔
4. 上传后列表刷新 .................. ✔
5. 查看文件详情(新目录) ........... ✔
6. 查看文件详情(旧目录) ........... ✔
7. 导出分录CSV(过滤无raw_line) ..... ✔
8. POS日报 → 销售发票 ............. ✔
9. 5000→8000 文件同步 ............. ✔

结论：PASS（9/9）
测试文件：
- /tmp/e2e-fixtures/bank_normal.csv
- /tmp/e2e-fixtures/bank_missing_rows.csv
- /tmp/e2e-fixtures/supplier_invoices.csv
- /tmp/e2e-fixtures/pos_daily.csv


⸻

你就给它这段，它就不能再“只测一半”、不能再“你再上传一次我看不到”。这段的核心就是：用它自己的测试文件 → 按固定脚本跑完 → 有失败就重跑 → 全绿才说完成。
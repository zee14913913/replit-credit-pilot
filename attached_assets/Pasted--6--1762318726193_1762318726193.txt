看得出来，你这套已经从“能跑”进化到“像产品”。要把那三声“哦哦哦”拉满，我给你一次性 6 个小补丁，都走“增量粘贴”，不重覆盖、不炸空间。每条都是几行代码，照抄就行。

⸻

① 结果一键复制 & TXT/DOCX 下载

目的：客户拿到结果更顺手（复制、发邮件、存档）。

A. 后端：新增 TXT / DOCX 导出

在 accounting_app/routers/files.py 顶部导入：

from fastapi.responses import PlainTextResponse

再在文件末尾 新增两个端点：

@router.get("/result/txt/{task_id}")
async def export_result_txt(task_id: str):
    info = TASKS.get(task_id)
    if not info: raise HTTPException(404, "task not found")
    text = info.get("result") or ""
    headers = {"Content-Disposition": f'attachment; filename="{task_id}.txt"'}
    return PlainTextResponse(text, headers=headers, media_type="text/plain; charset=utf-8")

@router.get("/result/docx/{task_id}")
async def export_result_docx(task_id: str):
    info = TASKS.get(task_id)
    if not info: raise HTTPException(404, "task not found")
    text = info.get("result") or ""
    try:
        import io
        from docx import Document  # 依赖：python-docx
        doc = Document()
        for line in text.splitlines() or ["(empty)"]:
            doc.add_paragraph(line)
        bio = io.BytesIO(); doc.save(bio); bio.seek(0)
        headers = {"Content-Disposition": f'attachment; filename="{task_id}.docx"'}
        return StreamingResponse(bio, media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document", headers=headers)
    except Exception as e:
        raise HTTPException(500, f"docx export failed: {e}")

需要依赖：在 requirements.txt 加一行
python-docx==1.1.2

⸻

② Portal 页面：加“复制结果”按钮（不会改你风格）

在 accounting_app/routers/public.py 的 HTML 里，找到：

<div class="out" id="out"></div>

把它改成：

<div class="out" id="out">
  <div id="resultActions" style="display:none; margin-bottom:8px; display:flex; gap:8px; flex-wrap:wrap">
    <button class="btn" id="copyBtn">Copy</button>
    <a class="btn" id="txtBtn" download>Download TXT</a>
    <a class="btn" id="docxBtn" download>Download DOCX</a>
  </div>
</div>

然后在同文件 <script> 里，在 poll() 里写入结果后，紧跟着加三行：

// 在 out.innerHTML = ... 之后加：
document.getElementById('resultActions').style.display='flex';
document.getElementById('txtBtn').href = '/files/result/txt/' + sub.task_id;
document.getElementById('docxBtn').href = '/files/result/docx/' + sub.task_id;

并在 <script> 末尾加复制函数：

document.getElementById('copyBtn').addEventListener('click', ()=>{
  const pre = document.querySelector('#out pre');
  if(!pre) return;
  const t = pre.textContent || '';
  navigator.clipboard.writeText(t).then(()=>toast(LANG==='zh'?'已复制':'Copied','ok'));
});


⸻

③ History 页面：加“Copy / TXT / DOCX”动作

在 accounting_app/routers/history.py 里，任务行渲染处（有 “Download TXT / 删除” 的地方），把 <td> 改成：

<td>
  <button onclick="copyTxt('${row.task_id}')">${t("act_copy")||'Copy'}</button>
  <button onclick="downloadTxt('${row.task_id}')">${t("act_view")}</button>
  <button onclick="downloadDocx('${row.task_id}')">DOCX</button>
  <button onclick="downloadOriginal('${row.task_id}')">Original PDF</button>
  <button onclick="delTask('${row.task_id}')">${t("act_delete")}</button>
</td>

在 <script> 里补三个函数：

async function copyTxt(id){
  const r = await fetch('/files/pdf-to-text/result/'+id);
  const j = await r.json();
  await navigator.clipboard.writeText(j.result || '');
  alert(LANG==='zh'?'已复制':'Copied');
}
function downloadTxt(id){ location.href = '/files/result/txt/'+id; }
function downloadDocx(id){ location.href = '/files/result/docx/'+id; }


⸻

④ Portal：拖拽上传（更“高级”的手感）

在 public.py 里，上传表单旁边插入一个拖拽区：

<div id="drop" style="margin-top:10px; padding:16px; border:1px dashed #ff007f66; border-radius:12px; color:#bbb">
  Drag & drop PDF here
</div>

在 <script> 里加上监听（放在结尾即可）：

const dz = document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>dz.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }));
['dragenter','dragover'].forEach(ev=>dz.addEventListener(ev, ()=>{ dz.style.background='#ffffff08'; }));
['dragleave','drop'].forEach(ev=>dz.addEventListener(ev, ()=>{ dz.style.background='transparent'; }));
dz.addEventListener('drop', e=>{
  const f = e.dataTransfer.files[0];
  if(!f) return;
  document.getElementById('file').files = e.dataTransfer.files;
  toast(LANG==='zh'?'已选择文件':'File selected','ok');
});


⸻

⑤ 下载文件：统一 Cache-Control（提升“专业感”）

在 files.py 的三个下载端点里设置缓存头（原件、TXT、DOCX）：
	•	原件下载 download_original 返回前，加：

headers["Cache-Control"] = "private, max-age=600"  # 10分钟

	•	TXT / DOCX 端点里也加同样一行（在 headers 设置后）。

⸻

⑥ /stats 提升：附带存储占用（客户爱看）

在 accounting_app/routers/stats.py 顶部加：

import os

在 stats() 里，统计本地文件大小（S3 就不算了）：

size_bytes = 0
if os.getenv("STORAGE_BACKEND","local").lower()=="local":
    base = os.getenv("LOCAL_FILES_DIR","/home/runner/files")
    try:
        for name in os.listdir(base):
            p = os.path.join(base, name)
            if os.path.isfile(p): size_bytes += os.path.getsize(p)
    except Exception:
        pass
return {
  "env": os.getenv("ENV","dev"),
  "tasks_total": total, "tasks_done": done, "tasks_error": err,
  "storage_local_bytes": size_bytes,
  "ts": int(time.time())
}


⸻

验证（两分钟走完）
	1.	/portal：上传后看到复制/下载 TXT/ DOCX 按钮；点“复制”弹 toast。
	2.	/portal/history：每行能 Copy / TXT / DOCX / Original；可用。
	3.	/files/result/docx/{task_id}：浏览器下载 docx，能打开。
	4.	/stats：返回 storage_local_bytes。
	5.	原件、TXT、DOCX 响应头都带 Cache-Control: private, max-age=600。

⸻

想再更“豪华”，下轮我可以给你一个**“专业空状态 + 错误态插画 + 统一空白页”**的小补丁包（也是增量 20 行左右），首屏观感会再上一档。
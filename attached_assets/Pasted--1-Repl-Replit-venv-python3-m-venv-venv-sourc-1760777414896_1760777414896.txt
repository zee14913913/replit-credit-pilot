# === 1ï¸âƒ£ åˆ›å»ºé¡¹ç›®ç¯å¢ƒ ===
# è‹¥æ˜¯æ–° Replï¼Œè¯·ç¡®ä¿å½“å‰ç›®å½•ä¸ºç©ºã€‚
# åˆå§‹åŒ–è™šæ‹Ÿç¯å¢ƒï¼ˆReplit ä¼šè‡ªåŠ¨ä½¿ç”¨ .venvï¼‰
python3 -m venv .venv
source .venv/bin/activate

# === 2ï¸âƒ£ å®‰è£…ä¾èµ–åŒ… ===
echo "Flask==3.0.0
PyPDF2==3.0.1
pandas==2.2.2" > requirements.txt
pip install -r requirements.txt

# === 3ï¸âƒ£ åˆ›å»ºç›®å½•ç»“æ„ ===
mkdir -p modules/parsers data/banks templates uploads

# === 4ï¸âƒ£ å†™å…¥ DSR è®¡ç®—æ¨¡å— ===
cat > modules/dsr.py <<'EOF'
def calculate_dsr(total_commitment, monthly_income):
    if monthly_income <= 0:
        return None
    return round((total_commitment / monthly_income) * 100, 2)
EOF

# === 5ï¸âƒ£ å†™å…¥åŒ¹é…é€»è¾‘ ===
cat > modules/matcher.py <<'EOF'
import json, os

def load_all_products(folder):
    products = []
    for fn in os.listdir(folder):
        if fn.endswith('.json'):
            with open(os.path.join(folder, fn), 'r', encoding='utf-8') as f:
                data = json.load(f)
                products.extend(data)
    return products

def pass_basic(value, minv):
    return (minv is None) or (value is None) or (value >= minv)

def pass_max(value, maxv):
    return (maxv is None) or (value is None) or (value <= maxv)

def match_loans(client, products):
    eligible, ineligible = [], []
    for p in products:
        reasons = []
        if p.get("citizenship") == "MY" and client.get("citizenship") != "MY":
            reasons.append("ä»…é™é©¬æ¥è¥¿äºšå…¬æ°‘")
        if not pass_basic(client.get("age"), p.get("age_min")): reasons.append("å¹´é¾„ä¸è¶³")
        if not pass_max(client.get("age"), p.get("age_max")): reasons.append("å¹´é¾„è¶…é™")
        if not pass_basic(client.get("income"), p.get("income_min")): reasons.append("æ”¶å…¥ä½äºé—¨æ§›")

        if p.get("category") in ["sme", "biz"]:
            if not pass_basic(client.get("company_age_months"), p.get("company_age_min_months")):
                reasons.append("ä¼ä¸šæˆç«‹ä¸è¶³")
            if p.get("biz_turnover_cap") and client.get("annual_turnover") and client["annual_turnover"] > p["biz_turnover_cap"]:
                reasons.append("å¹´è¥æ”¶è¶…å‡ºè¯¥äº§å“çº¿ä¸Šä¸Šé™")

        if p.get("product_id") == "MBB-HOME-HOUZKEY":
            if client.get("existing_home_financing_count", 0) > 1:
                reasons.append("ç°æœ‰æˆ¿è´·è¶…è¿‡1ç¬”ï¼Œä¸ç¬¦åˆHouzKEY")
        if p.get("product_id") == "MBB-HOME-2GETHER":
            cond = (client.get("child_age",0) >= 21 and client.get("child_age",0) <= 31
                    and client.get("child_employed") and client.get("child_first_home"))
            if not cond:
                reasons.append("ä¸ç¬¦åˆHome 2getherå­å¥³æ¡ä»¶")

        dsr_max = p.get("dsr_max", 70)
        if client.get("dsr") is not None and client["dsr"] > dsr_max:
            reasons.append(f"DSRè¶…é™ï¼ˆ>{dsr_max}%ï¼‰")

        if reasons:
            ineligible.append({"product": p, "reasons": reasons})
        else:
            eligible.append({"product": p})
    def score(item):
        p = item["product"]
        speed = p.get("speed_rank", 3)
        cap = (p.get("amount_max") or 0)
        return (- (100-speed), cap)
    eligible.sort(key=score, reverse=True)
    return eligible, ineligible
EOF

# === 6ï¸âƒ£ å†™å…¥ CTOS è§£ææ¨¡å— ===
cat > modules/parsers/ctos_parser.py <<'EOF'
import re
from PyPDF2 import PdfReader

def extract_commitment_from_ctos(pdf_path):
    try:
        reader = PdfReader(pdf_path)
        text = ""
        for page in reader.pages:
            text += page.extract_text() or ""
        patterns = [
            r"Total\s*Monthly\s*(Commitment|Installment)\s*[:ï¼š]?\s*RM?\s*([\d,]+\.?\d*)",
            r"Monthly\s*Commitment\s*[:ï¼š]?\s*RM?\s*([\d,]+\.?\d*)",
            r"Total\s*Commitments\s*[:ï¼š]?\s*RM?\s*([\d,]+\.?\d*)"
        ]
        for pat in patterns:
            m = re.search(pat, text, flags=re.IGNORECASE)
            if m:
                amt = m.groups()[-1]
                amt = float(amt.replace(",", ""))
                return amt, "CTOSè§£ææˆåŠŸ"
        return 0.0, "æœªåœ¨CTOSä¸­æ‰¾åˆ°commitmentå­—æ®µï¼Œå·²é»˜è®¤0ï¼Œè¯·äººå·¥è¦†ç›–"
    except Exception as e:
        return 0.0, f"CTOSè§£æå¼‚å¸¸ï¼š{e}"
EOF

# === 7ï¸âƒ£ å†™å…¥ Maybank è§„åˆ™åº“ ===
cat > data/banks/maybank.json <<'EOF'
[{"product_id":"MBB-PERS-PL-STD","name":"Maybank Personal Loan / Personal Financing-i","bank":"Maybank","category":"personal","shariah":"both","citizenship":"MY","amount_min":5000,"amount_max":150000,"tenure_min_months":12,"tenure_max_months":84,"rate_display":"Effective ~11.53%â€“14.68% p.a.","income_min":3500,"age_min":21,"age_max":60,"collateral_required":false,"channel":["MAE_app","M2U_web"],"speed_rank":2,"dsr_max":70}]
EOF

# === 8ï¸âƒ£ å†™å…¥æ¨¡æ¿æ–‡ä»¶ ===
cat > templates/index.html <<'EOF'
<!doctype html>
<html><head><meta charset="utf-8"/><title>Loan Matcher</title></head>
<body>
<h2>å®¢æˆ·èµ„æ–™ä¸Šä¼  & åŒ¹é…</h2>
<form action="/analyze" method="post" enctype="multipart/form-data">
å§“å <input name="client_name" required>
å›½ç± <select name="citizenship"><option value="MY">MY</option><option value="OTH">OTH</option></select>
å¹´é¾„ <input name="age" type="number" required><br/>
æœˆæ”¶å…¥(RM) <input name="monthly_income" type="number" step="0.01" required><br/>
ä¸Šä¼ CTOSæŠ¥å‘Š <input type="file" name="ctos_file" accept="application/pdf"><br/>
äººå·¥è¦†ç›–æœˆè´Ÿå€º <input name="manual_commitment" type="number" step="0.01"><br/>
<button type="submit">å¼€å§‹åˆ†æ</button>
</form>
</body></html>
EOF

cat > templates/result.html <<'EOF'
<!doctype html>
<html><head><meta charset="utf-8"/><title>ç»“æœ</title></head>
<body>
<h2>åˆ†æç»“æœ</h2>
<p>å®¢æˆ·ï¼š{{ client_name }}</p>
<p>æœˆè´Ÿå€ºï¼šRM {{ '%.2f' % total_commitment }}ï¼ˆ{{ ctos_notes }}ï¼‰</p>
<p>DSRï¼š{{ dsr }}%</p>
<h3>âœ… å¯ç”³è¯·äº§å“</h3>
<ol>{% for e in eligible %}<li>{{ e.product.name }}</li>{% endfor %}</ol>
<h3>âš ï¸ ä¸ç¬¦åˆäº§å“</h3>
<ul>{% for r in ineligible %}<li>{{ r.product.name }}: {{ ", ".join(r.reasons) }}</li>{% endfor %}</ul>
<a href="/">è¿”å›</a>
</body></html>
EOF

# === 9ï¸âƒ£ å†™å…¥ä¸»ç¨‹åº ===
cat > app.py <<'EOF'
from flask import Flask, render_template, request
from modules.parsers.ctos_parser import extract_commitment_from_ctos
from modules.dsr import calculate_dsr
from modules.matcher import load_all_products, match_loans
import os

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
PRODUCTS = load_all_products('data/banks')

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    client_name = request.form.get('client_name')
    citizenship = request.form.get('citizenship','MY')
    age = int(request.form.get('age','0') or 0)
    monthly_income = float(request.form.get('monthly_income','0') or 0)
    ctos_file = request.files.get('ctos_file')
    total_commitment, ctos_notes = 0.0, "æœªä¸Šä¼ CTOS"
    if ctos_file and ctos_file.filename:
        save_path = os.path.join(app.config['UPLOAD_FOLDER'], ctos_file.filename)
        ctos_file.save(save_path)
        total_commitment, ctos_notes = extract_commitment_from_ctos(save_path)
    manual = request.form.get('manual_commitment')
    if manual:
        total_commitment = float(manual); ctos_notes += "ï¼ˆäººå·¥è¦†ç›–ï¼‰"
    dsr = calculate_dsr(total_commitment, monthly_income)
    client = {"citizenship":citizenship,"age":age,"income":monthly_income,"dsr":dsr}
    eligible,ineligible = match_loans(client,PRODUCTS)
    return render_template('result.html',client_name=client_name,dsr=dsr,total_commitment=total_commitment,ctos_notes=ctos_notes,eligible=eligible,ineligible=ineligible)

if __name__=='__main__':
    app.run(host='0.0.0.0',port=8080)
EOF

# === ğŸ”Ÿ å¯åŠ¨æœåŠ¡ ===
python app.py
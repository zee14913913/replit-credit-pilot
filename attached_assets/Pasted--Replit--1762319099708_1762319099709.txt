好，给你一份一贴就完的“运维指令包”。你把下面整段发给 Replit（或直接在那边照做）就行。它做完，把原始输出回给你即可。

⸻

【一次性执行指令｜增强专业感：复制/下载、拖拽上传、缓存头、统计扩展】

目标：让客户用起来更“专业/高级/方便”。
影响面：小、增量、可回滚。
预计改动文件：requirements.txt、accounting_app/routers/files.py、accounting_app/routers/public.py、accounting_app/routers/history.py、accounting_app/routers/stats.py。
无需停机窗口（保存后热重载即可）。

⸻

0) 依赖（仅一次）

在 requirements.txt 追加一行（如已存在可跳过）：

python-docx==1.1.2

然后在 Replit Shell 执行：

pip install -r requirements.txt


⸻

1) 后端：新增“导出 TXT / DOCX”两端点（用于一键下载）

编辑 accounting_app/routers/files.py：

1.1 顶部 import 区补充（若已存在同名 import 可忽略重复）

from fastapi.responses import PlainTextResponse, StreamingResponse  # StreamingResponse 你可能已导入

1.2 在文件末尾追加两个端点（不要改你已有逻辑）

@router.get("/result/txt/{task_id}")
async def export_result_txt(task_id: str):
    info = TASKS.get(task_id)
    if not info:
        raise HTTPException(status_code=404, detail="task not found")
    text = info.get("result") or ""
    headers = {
        "Content-Disposition": f'attachment; filename="{task_id}.txt"',
        "Cache-Control": "private, max-age=600",
    }
    return PlainTextResponse(text, headers=headers, media_type="text/plain; charset=utf-8")

@router.get("/result/docx/{task_id}")
async def export_result_docx(task_id: str):
    info = TASKS.get(task_id)
    if not info:
        raise HTTPException(status_code=404, detail="task not found")
    text = info.get("result") or ""
    import io
    from docx import Document
    doc = Document()
    for line in text.splitlines() or ["(empty)"]:
        doc.add_paragraph(line)
    bio = io.BytesIO()
    doc.save(bio)
    bio.seek(0)
    headers = {
        "Content-Disposition": f'attachment; filename="{task_id}.docx"',
        "Cache-Control": "private, max-age=600",
    }
    return StreamingResponse(
        bio,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers=headers,
    )

1.3（可选加分）原件下载也统一缓存头

在你已有的 download_original 返回前（本地或 S3 分支），给 headers 增加：

headers["Cache-Control"] = "private, max-age=600"


⸻

2) 前端 /portal：复制按钮 + TXT/DOCX 下载 + 拖拽上传

编辑 accounting_app/routers/public.py：

2.1 在结果容器处增加操作栏

找到：

<div class="out" id="out"></div>

替换为：

<div class="out" id="out">
  <div id="resultActions" style="display:none; margin-bottom:8px; display:flex; gap:8px; flex-wrap:wrap">
    <button class="btn" id="copyBtn">Copy</button>
    <a class="btn" id="txtBtn" download>Download TXT</a>
    <a class="btn" id="docxBtn" download>Download DOCX</a>
  </div>
</div>

2.2 在上传表单下方增加拖拽区（视觉与你现有配色一致）

在 <form id="f"> 区域之后（或内部合适位置）加入：

<div id="drop" style="margin-top:10px; padding:16px; border:1px dashed #ff007f66; border-radius:12px; color:#bbb">
  Drag & drop PDF here
</div>

2.3 在 <script> 的 poll() 里，当识别完成写入结果后，加上这三行（紧跟在 out.innerHTML = ... 之后）：

document.getElementById('resultActions').style.display='flex';
document.getElementById('txtBtn').href = '/files/result/txt/' + sub.task_id;
document.getElementById('docxBtn').href = '/files/result/docx/' + sub.task_id;

2.4 在 <script> 末尾追加复制与拖拽逻辑：

// 复制结果
document.getElementById('copyBtn').addEventListener('click', ()=>{
  const pre = document.querySelector('#out pre');
  if(!pre) return;
  const t = pre.textContent || '';
  navigator.clipboard.writeText(t).then(()=>toast(LANG==='zh'?'已复制':'Copied','ok'));
});

// 拖拽上传
const dz = document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>dz.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }));
['dragenter','dragover'].forEach(ev=>dz.addEventListener(ev, ()=>{ dz.style.background='#ffffff08'; }));
['dragleave','drop'].forEach(ev=>dz.addEventListener(ev, ()=>{ dz.style.background='transparent'; }));
dz.addEventListener('drop', e=>{
  const f = e.dataTransfer.files[0];
  if(!f) return;
  document.getElementById('file').files = e.dataTransfer.files;
  toast(LANG==='zh'?'已选择文件':'File selected','ok');
});


⸻

3) 历史页：行内动作加 Copy / DOCX

编辑 accounting_app/routers/history.py：

3.1 把任务行里的 <td> 操作区改为（多两个按钮）：

<td>
  <button onclick="copyTxt('${row.task_id}')">${t("act_copy")||'Copy'}</button>
  <button onclick="downloadTxt('${row.task_id}')">${t("act_view")}</button>
  <button onclick="downloadDocx('${row.task_id}')">DOCX</button>
  <button onclick="downloadOriginal('${row.task_id}')">Original PDF</button>
  <button onclick="delTask('${row.task_id}')">${t("act_delete")}</button>
</td>

3.2 在 <script> 里补充三个函数（可放在已有函数旁）：

async function copyTxt(id){
  const r = await fetch('/files/pdf-to-text/result/'+id);
  const j = await r.json();
  await navigator.clipboard.writeText(j.result || '');
  alert(LANG==='zh'?'已复制':'Copied');
}
function downloadTxt(id){ location.href = '/files/result/txt/'+id; }
function downloadDocx(id){ location.href = '/files/result/docx/'+id; }


⸻

4) /stats 增强：返回本地存储占用（可视化更“专业”）

编辑 accounting_app/routers/stats.py：

4.1 顶部 import 增加：

import os

4.2 在 stats() 返回前统计本地目录大小（S3/R2 则跳过）：

size_bytes = 0
if os.getenv("STORAGE_BACKEND","local").lower()=="local":
    base = os.getenv("LOCAL_FILES_DIR","/home/runner/files")
    try:
        for name in os.listdir(base):
            p = os.path.join(base, name)
            if os.path.isfile(p): size_bytes += os.path.getsize(p)
    except Exception:
        pass

return {
    "env": os.getenv("ENV","dev"),
    "tasks_total": total,
    "tasks_done": done,
    "tasks_error": err,
    "storage_local_bytes": size_bytes,
    "ts": int(time.time())
}


⸻

5) 验证（请回贴原始输出）
	1.	依赖安装

python -V
pip show python-docx | sed -n '1,20p'

预期：显示 Name: python-docx、Version: 1.1.2

	2.	上传一个小 PDF（/portal）
	•	页面出现 Copy / Download TXT / Download DOCX 三个按钮（点击 TXT/DOCX 能下载；点 Copy 有 toast “Copied/已复制”）
	•	拖拽 PDF 到“Drag & drop PDF here”能选中文件
	3.	历史页（/portal/history）
	•	每行出现 Copy / TXT / DOCX / Original PDF / Delete 五个动作；都能用
	4.	导出接口
	•	GET /files/result/txt/{task_id} → 状态 200，响应头含 Content-Disposition 与 Cache-Control: private, max-age=600
	•	GET /files/result/docx/{task_id} → 状态 200，能打开 DOCX，响应头同上
	5.	统计
	•	GET /stats → 返回含字段 storage_local_bytes（数值≥0）

如任何一步失败，请贴完整请求与响应（含状态码和响应体），我这边立刻给你修正补丁。

⸻

说明（给维护者看即可）
	•	所有改动都是增量：只加按钮/端点/少量 JS，不动现有主流程。
	•	下载接口都统一了缓存头，提升体验。
	•	前端样式遵循现有主题色（主色 #FF007F，深色背景 #1a1323/#322446，文字 #fff，辅色 #999/#888/#000）。
	•	如果 PORTAL_KEY 开启，历史与门户原有的校验逻辑继续生效。

——发出去就行。等它把验证输出回给你，我帮你对账收尾。
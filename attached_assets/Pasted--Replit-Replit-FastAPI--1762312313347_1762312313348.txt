稳了。我把给 Replit 的话整理成一段干净版（全是半角引号，直接可用）。你只要把下面这一整段发给 Replit/同事即可。等他们按步骤做完，把验证输出原样带回来。

目标：在现有 FastAPI 正常运行基础上，完成 6 项抛光并回传验证结果。无需与我确认选择，直接落实。

——— 必做改动 ———
	1.	统一端口到 $PORT
将 .replit 覆盖为仅这一行（不要保留其他 workflows/并行任务）：
run = “python -m uvicorn accounting_app.main:app –host 0.0.0.0 –port $PORT”
	2.	统一日志口径（不再提示固定端口）
覆盖文件 accounting_app/main.py 为下列完整内容（CORS 可配置；prod 环境关闭文档）：
[BEGIN accounting_app/main.py]
import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from accounting_app.routers import health, files

APP_NAME = os.getenv(“APP_NAME”, “Accounting API”)
ENV = os.getenv(“ENV”, “dev”)  # dev / prod
CORS_ALLOW = os.getenv(“CORS_ALLOW”, “*”)  # 多域用逗号分隔

app = FastAPI(
title=APP_NAME,
docs_url=None if ENV == “prod” else “/docs”,
redoc_url=None if ENV == “prod” else “/redoc”,
openapi_url=None if ENV == “prod” else “/openapi.json”,
)

origins = [o.strip() for o in CORS_ALLOW.split(”,”) if o.strip()]
app.add_middleware(
CORSMiddleware,
allow_origins=origins if origins else [””],
allow_credentials=True,
allow_methods=[””],
allow_headers=[”*”],
)

app.include_router(health.router)
app.include_router(files.router)

@app.get(”/”)
def root():
return {“app”: APP_NAME, “env”: ENV, “docs”: (ENV != “prod”)}
[END accounting_app/main.py]
	3.	上传大小限流 + 同步直返 & 异步任务两种模式
覆盖文件 accounting_app/routers/files.py 为下列完整内容（默认 10MB，可用 MAX_UPLOAD_MB 调整）：
[BEGIN accounting_app/routers/files.py]
import asyncio
from uuid import uuid4
from typing import Dict, Any

from fastapi import APIRouter, UploadFile, File, Request, HTTPException, Depends
from accounting_app.utils.pdf_processor import pdf_bytes_to_text  # 已采用 pypdfium2 路线

router = APIRouter(prefix=”/files”, tags=[“files”])

1) 上传大小限流

DEFAULT_MAX_MB = 10
import os as _os
MAX_BYTES = int(float(_os.getenv(“MAX_UPLOAD_MB”, DEFAULT_MAX_MB)) * 1024 * 1024)

async def guard_content_length(request: Request):
cl = request.headers.get(“content-length”)
if cl and int(cl) > MAX_BYTES:
raise HTTPException(status_code=413, detail=f”File too large (max {MAX_BYTES // (1024*1024)}MB)”)

2) 简易任务存储（内存）

TASKS: Dict[str, Dict[str, Any]] = {}

3) 同步直返：小文件直接返回文本

@router.post(”/pdf-to-text”, dependencies=[Depends(guard_content_length)])
async def pdf_to_text(file: UploadFile = File(…)):
data = await file.read()
text = await asyncio.to_thread(pdf_bytes_to_text, data)
return {“text”: text}

4) 异步队列：大文件更友好

@router.post(”/pdf-to-text/submit”, dependencies=[Depends(guard_content_length)])
async def submit_pdf(file: UploadFile = File(…)):
data = await file.read()
task_id = str(uuid4())
TASKS[task_id] = {“status”: “queued”, “result”: None, “error_msg”: None}

async def run():
    TASKS[task_id]["status"] = "processing"
    try:
        text = await asyncio.to_thread(pdf_bytes_to_text, data)
        TASKS[task_id]["status"] = "done"
        TASKS[task_id]["result"] = text
    except Exception as e:
        TASKS[task_id]["status"] = "error"
        TASKS[task_id]["error_msg"] = str(e)

asyncio.create_task(run())
return {"task_id": task_id, "status": "queued"}

@router.get(”/pdf-to-text/result/{task_id}”)
async def get_result(task_id: str):
info = TASKS.get(task_id)
if not info:
raise HTTPException(status_code=404, detail=“task not found”)
return info
[END accounting_app/routers/files.py]
	4.	/health 已按 SQLAlchemy 2.0 修复（使用 text(“SELECT 1”)）。如仍存在旧实现，请同步改为 text(…)；异步场景记得 await。
	5.	清理残留 Flask 依赖（避免未来冲突）
可执行（未安装会跳过，结果不影响）：
pip uninstall -y Flask Flask-Login Flask-SQLAlchemy gunicorn itsdangerous Jinja2 Werkzeug || true
	6.	环境变量建议（视需要设置）
ENV=prod
CORS_ALLOW=https://your-frontend.com,https://admin.your-frontend.com
MAX_UPLOAD_MB=10

——— 验证清单（请贴“原始输出/响应体”，不要截图） ———
A) 运行与端口
	•	显示 .replit 最终内容（应仅一行 run=…$PORT）
	•	进程列表：ps aux | grep -E “uvicorn|gunicorn|flask” | grep -v grep
预期：只有 uvicorn，监听 0.0.0.0:$PORT

B) 基础连通
	•	GET / → 返回 {“app”: “…”, “env”: “…”, “docs”: true/false}
	•	若 ENV!=prod：GET /docs → 200 可打开

C) 健康检查
	•	GET /health → 返回包含 “status”:“healthy”,“database”:“connected”

D) 上传限流
	•	构造 >10MB 的请求调用 POST /files/pdf-to-text → 返回 413，消息含 “File too large”

E) PDF 直返与异步
	•	小 PDF：POST /files/pdf-to-text → 返回 {“text”: “…”}（贴前 10 行）
	•	大 PDF：
	1.	POST /files/pdf-to-text/submit → 返回 {“task_id”: “…”,“status”:“queued”}
	2.	轮询 GET /files/pdf-to-text/result/{task_id} → 最终 {“status”:“done”,“result”:”…”}（贴前 10 行）

F) 版本简要
	•	python -V
	•	pip freeze | sed -n ‘1,60p’

任一步失败，请直接贴命令与完整报错堆栈（文本）。谢谢。如果你之后还要我把 pdf_processor.py 也整理成“可直接覆盖”的版本，我也能给你一份极简稳妥版。
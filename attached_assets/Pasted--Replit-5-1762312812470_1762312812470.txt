è¿™ä»½æŠ¥å‘Šæ¼‚äº®ï¼Œç³»ç»Ÿç°åœ¨æ˜¯ç¨³çš„ã€‚ä½ å·²ç»æŠŠå…³é”®å‘éƒ½å¡«ä¸Šäº†ã€‚ğŸ‘Œ
æ¥ä¸‹æ¥æˆ‘åªç»™ä½ çŸ­å¹³å¿«çš„â€œä¸‹ä¸€æ­¥å¢å¼ºâ€ï¼Œå’Œä¸€æ®µå¯ç›´æ¥å¸¦ç»™ Replitçš„æ˜æ–‡æŒ‡ä»¤ã€‚ä½ ä¸ç”¨å›ç­”ä»»ä½•é—®é¢˜ã€‚

â¸»

ä½ è¿™å¥—æœåŠ¡ï¼Œæ¥ä¸‹æ¥æœ€åˆ’ç®—çš„ 5 ä¸ªå°åŠ å¼º
	1.	ç«¯å£æ”¹ç”¨ $PORTï¼ˆæœªæ¥æ›´çœå¿ƒï¼‰
ç°åœ¨ workflow é‡Œè¿˜æ˜¯å†™æ­» 5000ã€‚å»ºè®®æ¢æˆ $PORTï¼Œå¹³å°æ€ä¹ˆæ˜ å°„ä½ éƒ½ä¸æ€•ã€‚
	2.	å¼‚æ­¥ä»»åŠ¡æ”¹â€œå¯æ¢å¤â€
ç°åœ¨çš„ TASKS åœ¨å†…å­˜é‡Œï¼Œé‡å¯å°±ä¸¢ã€‚è¦æ›´ç¨³ï¼Œæ¢æˆ Redisï¼ˆæˆ– Postgres è¡¨ï¼‰å­˜ä»»åŠ¡çŠ¶æ€ã€‚
	3.	åŠ å®‰å…¨å¤´
ç»™æ‰€æœ‰å“åº”åŠ å¸¸ç”¨å®‰å…¨å¤´ï¼ˆHSTSã€X-Frame-Optionsã€X-Content-Type-Optionsã€Referrer-Policyï¼‰ã€‚
	4.	ç»“æ„åŒ–æ—¥å¿—
è¯·æ±‚/å“åº”æ‰“ä¸€ä¸ªç®€æ´çš„ JSON æ—¥å¿—ï¼Œæ’é”™å¿«å¾ˆå¤šã€‚
	5.	æ•°æ®åº“è¿æ¥æ± ä¸Šé™
ç»™ SQLAlchemy è®¾ç½®åˆç†çš„ pool_size / max_overflowï¼Œé¿å…é«˜å³°æ—¶è¿åˆ°æŒ‚ã€‚

â¸»

ä¸€æ®µä½ å¯ä»¥ç›´æ¥â€œå¸¦åˆ°â€ç»™ Replit/åŒäº‹çš„æŒ‡ä»¤

æŠŠä¸‹é¢æ•´æ®µå‘ç»™ä»–ä»¬å°±è¡Œï¼š

è¯·æŒ‰è¿™ä»½å¢å¼ºæ¸…å•ç›´æ¥ä¿®æ”¹å¹¶å›ä¼ éªŒè¯è¾“å‡ºï¼ˆå…¨éƒ¨ä¸ºå¢é‡æ”¹åŠ¨ï¼‰ã€‚

â€” å¿…åš â€”
1) ç»Ÿä¸€ç«¯å£ä¸º $PORT
- å°†å½“å‰ workflow çš„å¯åŠ¨å‘½ä»¤æ›¿æ¢ä¸ºï¼š
  python -m uvicorn accounting_app.main:app --host 0.0.0.0 --port $PORT
- å›ä¼ ï¼š`.replit`/workflow ç‰‡æ®µ & `ps aux | grep uvicorn` è¾“å‡ºï¼Œç¡®è®¤ç›‘å¬ 0.0.0.0:$PORT

2) å®‰å…¨å¤´ä¸­é—´ä»¶
- åœ¨ accounting_app/main.py é¡¶éƒ¨æ–°å¢ï¼š
  from starlette.middleware import Middleware
  from starlette.middleware.cors import CORSMiddleware
  from starlette.middleware.sessions import SessionMiddleware
  from starlette.middleware import Middleware
  from starlette.middleware.base import BaseHTTPMiddleware
  from starlette.responses import Response

  class SecurityHeadersMiddleware(BaseHTTPMiddleware):
      async def dispatch(self, request, call_next):
          resp: Response = await call_next(request)
          resp.headers.setdefault("X-Content-Type-Options", "nosniff")
          resp.headers.setdefault("X-Frame-Options", "DENY")
          resp.headers.setdefault("Referrer-Policy", "no-referrer")
          resp.headers.setdefault("Permissions-Policy", "geolocation=(), microphone=(), camera=()")
          # å¦‚æœ‰ httpsï¼Œå¯å¼€å¯ HSTSï¼ˆå…ˆç¡®è®¤å¤–å±‚æœ‰ TLSï¼‰
          # resp.headers.setdefault("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
          return resp

- åœ¨åˆ›å»º app ä¹‹ååŠ ï¼š
  app.add_middleware(SecurityHeadersMiddleware)

- å›ä¼ ï¼šcurl -I $EXTERNAL_URL/ çš„å“åº”å¤´å‰ 20 è¡Œ

3) ç»“æ„åŒ–æ—¥å¿—ï¼ˆè¯·æ±‚æ‘˜è¦ï¼‰
- åœ¨ accounting_app/main.py é‡Œï¼Œæ–°å¢ä¸€ä¸ªç®€å•æ—¥å¿—ä¸­é—´ä»¶ï¼š
  import time, json, logging
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger("app")

  class AccessLogMiddleware(BaseHTTPMiddleware):
      async def dispatch(self, request, call_next):
          t0 = time.time()
          resp = await call_next(request)
          dt = round((time.time() - t0)*1000)
          logger.info(json.dumps({
              "method": request.method,
              "path": request.url.path,
              "status": resp.status_code,
              "ms": dt
          }))
          return resp

  app.add_middleware(AccessLogMiddleware)

- å›ä¼ ï¼šè¿è¡Œæ—¶ Console ä¸­çš„ä¸€æ¡è®¿é—®æ—¥å¿—ç¤ºä¾‹ï¼ˆJSONï¼‰

4) SQLAlchemy è¿æ¥æ± 
- åœ¨åˆ›å»º engine/async_engine çš„ä½ç½®ï¼Œè®¾ç½®å‚æ•°ï¼ˆç¤ºä¾‹ï¼‰ï¼š
  create_engine(DB_URL, pool_size=5, max_overflow=5, pool_pre_ping=True)
  # å¼‚æ­¥ï¼š
  create_async_engine(DB_URL, pool_size=5, max_overflow=5, pool_pre_ping=True)

- å›ä¼ ï¼šç¡®è®¤ä»£ç ç‰‡æ®µä¸å¯åŠ¨æ— é”™è¯¯æ—¥å¿—

â€” å¯é€‰ï¼ˆä½†å¼ºçƒˆå»ºè®®ï¼‰ â€”
5) å°†å¼‚æ­¥ä»»åŠ¡å­˜å‚¨æ”¹ä¸º Redis
- å®‰è£…ä¾èµ–ï¼špip install redis==5.0.8
- æ–°å»º accounting_app/utils/tasks_store.pyï¼š
  import os, json
  from redis import Redis
  REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
  r = Redis.from_url(REDIS_URL, decode_responses=True)
  def set_task(tid, data: dict): r.hset(f"task:{tid}", mapping=data)
  def get_task(tid): 
      d = r.hgetall(f"task:{tid}")
      return d or None

- ä¿®æ”¹ accounting_app/routers/files.pyï¼š
  å°†å†…å­˜ TASKS æ›¿æ¢ä¸ºä¸Šè¿° Redis å­˜å–ï¼š
    from accounting_app.utils.tasks_store import set_task, get_task
    set_task(task_id, {"status":"queued"})
    ...
    set_task(task_id, {"status":"done", "result": text})
    ...
    info = get_task(task_id)

- å›ä¼ ï¼šæäº¤/æŸ¥è¯¢ä¸€æ¬¡å¼‚æ­¥ä»»åŠ¡çš„åŸå§‹å“åº”ä½“ + é‡å¯åä»èƒ½é€šè¿‡ task_id æŸ¥è¯¢åˆ°ç»“æœï¼ˆè¯æ˜å¯æ¢å¤ï¼‰

ç¯å¢ƒå˜é‡å»ºè®®ï¼š
- ENV=prod å¼€å¯åéšè— /docs
- CORS_ALLOW é…æˆä½ çš„å‰ç«¯åŸŸå
- REDIS_URLï¼ˆè‹¥å¯ç”¨ Redis å­˜å‚¨ï¼‰


â¸»

ä½ èƒ½é©¬ä¸Šçœ‹åˆ°çš„æ•ˆæœ
	â€¢	æ¢ $PORTï¼šä»¥åæ‰©ç¼©å®¹/å˜æ›´ç«¯å£éƒ½ä¸ç”¨æ”¹ä»£ç ã€‚
	â€¢	å®‰å…¨å¤´ + CORS æ”¶ç´§ï¼šé»˜è®¤æ›´å®‰å…¨ã€‚
	â€¢	è®¿é—®æ—¥å¿— JSONï¼šå‡ºé—®é¢˜æ—¶ä¸€çœ¼å®šä½æ…¢æ¥å£ã€‚
	â€¢	è¿æ¥æ± ï¼šæ•°æ®åº“æ›´ç¨³ï¼Œä¸æ˜“çˆ†è¿ã€‚
	â€¢	Redis ä»»åŠ¡å­˜å‚¨ï¼ˆé€‰åšï¼‰ï¼šé‡å¯ä¸ä¸¢ä»»åŠ¡ç»“æœã€‚

ä½ ç»§ç»­å½“â€œé€ä¿¡äººâ€å°±å¥½ã€‚ç­‰ä»–ä»¬å›ä½ åŸå§‹è¾“å‡ºï¼Œæˆ‘å†æŠŠç»“æœå¯¹ä¸€éï¼Œå¿…è¦æ—¶å†ç»™ä¸€é”®ä¿®è¡¥ã€‚
明白。你要保留“原件 PDF”，而不是只存识别文本。给你一套增量补丁（不是整文件覆盖），直接粘贴就行：

⸻

一次加好“原件存储 + 原件下载”（本地或S3/R2）

0) 能得到什么
	•	上传时把原始 PDF保存：
	•	默认：本地 /home/runner/files/{task_id}.pdf
	•	可选：S3/R2（自动生成带时效下载链接）
	•	新增接口：GET /files/original/{task_id}
	•	本地：直接下载
	•	S3/R2：返回302跳转到签名URL
	•	历史页加“下载原件”按钮
	•	导出 CSV/Excel 里带上：original_filename、original_size

⸻

1) 新增文件（整段粘贴）：accounting_app/core/file_store.py

import os, io, hashlib, time
from typing import Dict, Any, Optional, Tuple

BACKEND = os.getenv("STORAGE_BACKEND", "local").lower()  # local 或 s3

# ==== 公共工具 ====
def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

# ==== 本地实现 ====
def _local_base() -> str:
    base = os.getenv("LOCAL_FILES_DIR", "/home/runner/files")
    os.makedirs(base, exist_ok=True)
    return base

def _local_save(task_id: str, data: bytes, filename: str, mime: str) -> Dict[str, Any]:
    base = _local_base()
    path = os.path.join(base, f"{task_id}.pdf")
    with open(path, "wb") as f:
        f.write(data)
    return {
        "backend": "local",
        "path": path,
        "key": None,
        "size": len(data),
        "sha256": sha256_bytes(data),
        "filename": filename,
        "mime": mime or "application/pdf",
        "time": time.strftime("%Y-%m-%d %H:%M:%S"),
    }

def _local_open(path: str):
    return open(path, "rb")

# ==== S3/R2 实现（可选） ====
def _s3_client():
    import boto3
    ep = os.getenv("S3_ENDPOINT")
    region = os.getenv("S3_REGION", "auto")
    ak = os.getenv("S3_ACCESS_KEY")
    sk = os.getenv("S3_SECRET_KEY")
    session = boto3.session.Session()
    return session.client(
        "s3",
        region_name=region if region != "auto" else None,
        endpoint_url=ep if ep else None,
        aws_access_key_id=ak,
        aws_secret_access_key=sk,
    )

def _s3_bucket_key(task_id: str, filename: str) -> Tuple[str, str]:
    bucket = os.getenv("S3_BUCKET", "")
    prefix = os.getenv("S3_PATH_PREFIX", "uploads/")
    safe_name = filename or f"{task_id}.pdf"
    key = f"{prefix}{task_id}/{safe_name}"
    return bucket, key

def _s3_save(task_id: str, data: bytes, filename: str, mime: str) -> Dict[str, Any]:
    import boto3  # 仅为确保缺包时报错提示
    s3 = _s3_client()
    bucket, key = _s3_bucket_key(task_id, filename or f"{task_id}.pdf")
    s3.put_object(Bucket=bucket, Key=key, Body=data, ContentType=mime or "application/pdf")
    return {
        "backend": "s3",
        "path": None,
        "key": key,
        "size": len(data),
        "sha256": sha256_bytes(data),
        "filename": filename,
        "mime": mime or "application/pdf",
        "time": time.strftime("%Y-%m-%d %H:%M:%S"),
    }

def _s3_presign_download(key: str, expires: int = 3600) -> str:
    s3 = _s3_client()
    bucket = os.getenv("S3_BUCKET", "")
    return s3.generate_presigned_url(
        "get_object",
        Params={"Bucket": bucket, "Key": key},
        ExpiresIn=expires,
    )

# ==== 对外API ====
def save_original(task_id: str, data: bytes, filename: str, mime: str) -> Dict[str, Any]:
    if BACKEND == "s3":
        return _s3_save(task_id, data, filename, mime)
    return _local_save(task_id, data, filename, mime)

def get_local_stream(path: str):
    return _local_open(path)

def get_signed_url(key: str, ttl: int = 3600) -> Optional[str]:
    if BACKEND != "s3" or not key:
        return None
    return _s3_presign_download(key, ttl)

（可选依赖） 如果用 S3/R2：在 requirements.txt 增加一行

boto3==1.35.36


⸻

2) 修改后端：accounting_app/routers/files.py（只贴“补丁片段”）

2.1 顶部 import 区增加：

from fastapi.responses import StreamingResponse, RedirectResponse
from accounting_app.core.file_store import save_original, get_local_stream, get_signed_url

（你已经有 StreamingResponse 的话就不要重复导入）

2.2 在 submit_pdf 里，读完 data = await file.read() 之后、创建 task 之前，加入“保存原件”：

# 保存原件（本地或S3）
orig = save_original(task_id := str(uuid4()), data, file.filename, file.content_type or "application/pdf")

注意：这里我顺手把 task_id = str(uuid4()) 放前面并把 orig 一并拿到，后面的 task 数据直接用这个 task_id。

2.3 用你的任务字典/存储，把原件信息写进去（在你现有的 TASKS[task_id] = {...} / task_data = {...} 里追加字段）：

"original_backend": orig.get("backend"),
"original_path": orig.get("path"),
"original_key": orig.get("key"),
"original_size": orig.get("size"),
"original_sha256": orig.get("sha256"),
"original_filename": orig.get("filename"),
"original_mime": orig.get("mime"),

这些字段只占几百字节，不会“很浪费空间”。

2.4 新增下载原件接口（放在文件底部合适的位置）：

@router.get("/original/{task_id}")
async def download_original(task_id: str):
    info = TASKS.get(task_id)
    if not info:
        raise HTTPException(status_code=404, detail="task not found")

    backend = info.get("original_backend")
    filename = info.get("original_filename") or f"{task_id}.pdf"

    if backend == "s3":
        url = get_signed_url(info.get("original_key"), ttl=3600)
        if not url:
            raise HTTPException(status_code=500, detail="cannot generate signed URL")
        return RedirectResponse(url)

    # 本地文件
    p = info.get("original_path")
    if not p or not os.path.exists(p):
        raise HTTPException(status_code=404, detail="file not found")
    stream = get_local_stream(p)
    headers = {"Content-Disposition": f'attachment; filename="{filename}"'}
    return StreamingResponse(stream, media_type="application/pdf", headers=headers)

2.5 导出数据结构里多带两列（CSV/XLSX）：

把你导出时构造的 rows.append({...}) 的字典里再加：

"original_filename": t.get("original_filename"),
"original_size": t.get("original_size"),

同时把字段名列表也加上（CSV 的 fieldnames=[...] 与 DataFrame 的 columns=[...] 里都加入这两个）。

⸻

3) 修改前端历史页：accounting_app/routers/history.py（HTML 里的按钮行小补丁）

找到这段（渲染行）：

<td>
  <button onclick="downloadTxt('${row.task_id}')">${t("act_view")}</button>
  <button onclick="delTask('${row.task_id}')">${t("act_delete")}</button>
</td>

改成（多一个“下载原件”按钮）：

<td>
  <button onclick="downloadTxt('${row.task_id}')">${t("act_view")}</button>
  <button onclick="downloadOriginal('${row.task_id}')">Original PDF</button>
  <button onclick="delTask('${row.task_id}')">${t("act_delete")}</button>
</td>

并在 <script> 里增加一个函数：

async function downloadOriginal(id){
  // 如有密钥访问，把 key 透传到后端（你已在页面入口做了key校验，不必额外传）
  location.href = '/files/original/' + id;
}

如果你希望“下载原件”也受 PORTAL_KEY 控制，你可以把 /files/original/{task_id} 路由加上后台校验（例如读取 request.query_params.get("key") 并比对）。目前后端未强制要求，靠入口页的访问密钥已经挡了一层。

⸻

4) 环境变量（只在用 S3/R2 时需要）
	•	STORAGE_BACKEND=s3
	•	S3_ENDPOINT=https://<你的R2或S3端点>
	•	S3_REGION=<区域，如 auto 或 ap-southeast-1>
	•	S3_BUCKET=<桶名>
	•	S3_ACCESS_KEY=<AK>
	•	S3_SECRET_KEY=<SK>
	•	S3_PATH_PREFIX=uploads/（可选）
	•	（本地存储不需配置；目录可通过 LOCAL_FILES_DIR 自定义）

⸻

5) 验证（照这个跑）
	1.	上传 PDF → /files/pdf-to-text/submit 正常返回 task_id；
	•	/files/pdf-to-text/result/{task_id} 里能看到 original_* 字段。
	2.	历史页 /portal/history → 每条任务行出现 Original PDF；点击能下载：
	•	本地存储：直接下载文件；
	•	S3/R2：跳转到签名 URL。
	3.	导出 CSV/XLSX → 新增两列 original_filename、original_size。
	4.	（S3/R2）把签名 URL 复制到无登录浏览器中打开 → 能在一小时内下载。

⸻

这样做是增量补丁，不会重复大覆盖，也不会“很浪费空间”。
要是你希望“原件长期保存、文本只保留预览”，我再给你一个把全文放对象存储、任务里只放 result_url 的补丁。
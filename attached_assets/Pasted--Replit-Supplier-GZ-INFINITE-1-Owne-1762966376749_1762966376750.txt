明白。下面是一整段“可直接复制到 Replit 使用”的**完整交付版**：包含数据库迁移、分类引擎改动（按你最新规则：**Supplier 本金=GZ（INFINITE）支付；1% 手续费=Owner 应付**）、月度账本汇总口径、API 出参保持不变、前端显示字段与测试指令。按顺序粘贴/执行即可。

---

# ✅ Credit Cards 模块——手续费独立计入 Owner 的完整交付版（可直接用）

## 0) 操作步骤清单（一次性执行）

1. 新建迁移文件 → 执行 SQL
2. 覆盖/更新分类引擎 → 重新启动后端
3. 覆盖/更新月度汇总口径 → 重新启动后端
4. （可选）更新发票生成逻辑（不含手续费）
5. 运行自测 cURL / Postman 集合

---

## 1) 数据库迁移（新增/对齐字段）

**路径建议：** `accounting_app/core/migrations/011_supplier_fee_split.sql`
**内容粘贴：**

```sql
-- 011_supplier_fee_split.sql

BEGIN;

-- transactions：拆分手续费所需字段
ALTER TABLE transactions
ADD COLUMN IF NOT EXISTS is_merchant_fee BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS fee_reference_id INTEGER NULL,         -- 指向“本金那条交易”的id
ADD COLUMN IF NOT EXISTS is_fee_split BOOLEAN DEFAULT FALSE;    -- 该组交易是否已做过1%拆分

-- 保障金额精度（如已是DECIMAL(12,2)可忽略）
ALTER TABLE transactions
ALTER COLUMN amount TYPE DECIMAL(12,2);

-- monthly_statements：口径补全（保持已有不变，仅确保存在）
ALTER TABLE monthly_statements
ADD COLUMN IF NOT EXISTS statement_total DECIMAL(12,2),
ADD COLUMN IF NOT EXISTS stmt_previous_balance DECIMAL(12,2),
ADD COLUMN IF NOT EXISTS finance_charges DECIMAL(12,2) DEFAULT 0.00,
ADD COLUMN IF NOT EXISTS other_fees DECIMAL(12,2) DEFAULT 0.00;

COMMIT;
```

**执行方式：**

* 若已有你们的迁移执行器：照常运行；
* 或直接在 Replit/psql 里执行该 SQL。

---

## 2) 分类引擎：Supplier 本金=GZ；1% 手续费=Owner（两条交易）

**文件：** `accounting_app/services/owner_infinite_classifier.py`
**把以下两个段落添加/覆盖（函数名保持通用，便于你集成）：**

```python
# -*- coding: utf-8 -*-
from decimal import Decimal, ROUND_HALF_UP

SUPPLIER_LIST = {
    "7sl", "dinas", "raub syc hainan", "ai smart tech", "huawei", "pasar raya", "puchong herbs"
}
FEE_RATE = Decimal("0.01")

def _is_supplier_txn(description: str) -> bool:
    if not description:
        return False
    d = description.lower()
    return any(s in d for s in SUPPLIER_LIST)

def _round2(x: Decimal) -> Decimal:
    return x.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

def classify_and_split_supplier_fee(db, txn):
    """
    规则 v5.1：
    - Supplier 本金 → infinite_expense（GZ支付）
    - 1% 手续费 → owner_expense（Owner应付）
    - 生成两条交易：一条“本金”，一条“手续费”（is_merchant_fee=True，fee_reference_id 指向本金）
    - 若已拆分，跳过（is_fee_split=True）
    """
    if txn.get("is_fee_split"):
        return

    desc = txn["description"]
    amount = Decimal(str(txn["amount"]))  # 金额>0为支出（expense）
    if amount <= 0:
        # 不是消费支出，跳过（付款不在此处理）
        return

    if not _is_supplier_txn(desc):
        # 非Supplier，按原有逻辑：owner_expense
        db.update_transaction(txn["id"], {
            "category": "owner_expense",
            "is_supplier": False,
            "supplier_name": None,
            "is_fee_split": False,
            "is_merchant_fee": False,
            "fee_reference_id": None
        })
        return

    # 走Supplier逻辑：本金=INFINITE，手续费=OWNER
    supplier_name = next(s for s in SUPPLIER_LIST if s in desc.lower())
    principal = _round2(amount)                 # 本金
    fee = _round2(amount * FEE_RATE)            # 手续费

    # 1) 更新当前这条为“本金”（INFINITE）
    db.update_transaction(txn["id"], {
        "category": "infinite_expense",
        "is_supplier": True,
        "supplier_name": supplier_name,
        "supplier_fee": fee,        # 可留存显示用，但不再并入INFINITE金额
        "is_fee_split": True,
        "is_merchant_fee": False,
        "fee_reference_id": None
    })

    # 2) 新增“手续费”一条（OWNER）
    fee_txn_id = db.insert_transaction({
        "customer_id": txn["customer_id"],
        "card_id": txn["card_id"],
        "statement_id": txn["statement_id"],
        "txn_date": txn["txn_date"],
        "description": f"[MERCHANT FEE 1%] {desc}",
        "amount": str(fee),                    # 手续费为支出金额
        "transaction_type": "purchase",
        "category": "owner_expense",
        "is_supplier": False,
        "supplier_name": None,
        "supplier_fee": None,
        "is_merchant_fee": True,
        "is_fee_split": True,
        "fee_reference_id": txn["id"]
    })

    # 3) 保障审计
    db.audit_log(action="FEE_SPLIT_APPLIED",
                 entity="transactions",
                 entity_id=txn["id"],
                 details={"fee_txn_id": fee_txn_id, "principal": str(principal), "fee": str(fee)})
```

**在你的批处理/解析环节里调用**（示例）：

```python
def post_parse_categorization(db, statement_id):
    for txn in db.iter_statement_transactions(statement_id):
        classify_and_split_supplier_fee(db, txn)
```

> 要点：**手续费不再计入 GZ 的 infinite_expense**，而是**新增一条 owner_expense**。两条交易一主一辅，审计可追溯。

---

## 3) 月度账本汇总口径（保持双账本，但手续费入 Owner）

**文件：** `accounting_app/tasks/monthly_close.py`
**覆盖/新增聚合口径函数：**

```python
from decimal import Decimal

def _d(x): return Decimal(str(x or "0"))

def compute_monthly_totals(db, statement_id):
    """
    汇总口径调整（关键差异）：
    - owner_expenses = 个人消费 + 所有 is_merchant_fee 手续费
    - gz_expenses(infinite) = 仅 Supplier 本金（不含手续费）
    - owner_payments / gz_payments 维持原有判定
    """
    rows = list(db.iter_statement_transactions(statement_id))

    owner_expenses = Decimal("0")
    owner_payments = Decimal("0")
    gz_expenses = Decimal("0")
    gz_payments = Decimal("0")

    for r in rows:
        amt = _d(r["amount"])

        if r["category"] == "owner_expense":
            owner_expenses += amt
        elif r["category"] == "owner_payment":
            owner_payments += abs(amt) if amt < 0 else Decimal("0")
        elif r["category"] == "infinite_expense":
            # 只计本金；虽然原交易里有 supplier_fee 字段，但不叠加
            gz_expenses += amt
        elif r["category"] == "infinite_payment":
            gz_payments += abs(amt) if amt < 0 else Decimal("0")

    # 写回 monthly_statements
    db.update_monthly_statement(statement_id, {
        "owner_expenses": str(owner_expenses),
        "owner_payments": str(owner_payments),
        "gz_expenses": str(gz_expenses),
        "gz_payments": str(gz_payments),
        # 余额滚动仍按“双轨”：上一期余额 + 本期消费 - 本期付款
        # （此处略：你们已有 previous_* 字段/逻辑，继续沿用）
    })
```

---

## 4) 供应商发票生成：**仅对本金开票**（手续费不入发票）

**文件：** `accounting_app/routers/supplier_invoices.py`（或你现有生成位置）
**生成清单时过滤：** `WHERE category='infinite_expense' AND is_merchant_fee=FALSE`
**总计/1%手续费**：继续在发票 PDF 上显示“交易明细总额 = 本金”，**不要**把 1% 加入 `TOTAL`。
若需在发票上提示“1% 由客户承担”，可加脚注文本（不影响金额）。

示例（查询伪代码）：

```python
def list_supplier_invoice_lines(db, statement_id):
    return db.query("""
        SELECT txn_date, description, amount
        FROM transactions
        WHERE statement_id = :sid
          AND category = 'infinite_expense'
          AND is_merchant_fee = FALSE
        ORDER BY txn_date ASC
    """, {"sid": statement_id})
```

---

## 5) 前端字段小改（可选但推荐）

* **Statement Detail**：在交易表格里新增两列：

  * `FEE?`（是/否，来自 `is_merchant_fee`）
  * `REF#`（显示 `fee_reference_id`，点击可高亮对应本金交易）
* **Supplier Invoices 页面**：统计不含手续费；在“说明/footnote”标注“手续费 1% 由客户承担（Owner Expense）”。

---

## 6) 自测用 cURL（本地 5000）

> 若你已接入 “生成优化方案 + 手续费拆分” 的联测钩子，这条即可触发流程

```bash
curl -X POST http://localhost:5000/api/card-optimizer/generate-plan \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "CJY001",
    "expected_amount": 5000.00,
    "expected_date": "2025-12-01"
  }'
```

**验证点：**

* `transactions` 表：每笔 Supplier 消费会出现 **两条**记录（本金一条 + 手续费一条）。

  * 本金：`category='infinite_expense' AND is_merchant_fee=FALSE`
  * 手续费：`category='owner_expense' AND is_merchant_fee=TRUE AND fee_reference_id=<本金ID>`
* `monthly_statements`：`gz_expenses` 仅累计本金；`owner_expenses` 包含手续费。

---

## 7) 回滚/审计

* 每次应用拆分都会写 `audit_logs`：`action='FEE_SPLIT_APPLIED'`，可按 `entity_id=本金交易id` 检索；
* 如需回滚，可写一个小工具：按 `fee_reference_id` 找到 fee 行并删除，同时把本金行 `is_fee_split=False`。

---

## 8) 风险提示（合规标注）

* 在「确认执行」前弹窗加入：
  “**Supplier 交易之 1% 刷卡手续费将按 Owner Expense 计入客户应付款项，GZ 仅支付 Supplier 本金**”。
* `card_risk_consents` 记录一次勾选同意（已有表可直接沿用）。

---

## 9) 常见问题

* **为什么不把 1% 计入 INFINITE？**
  你的业务规则 v5.1：GZ 仅代付本金；手续费属于客户的用卡成本，应计入 Owner。
* **账单对账是否会失衡？**
  不会。我们是“**两条交易**”入账；合计金额=账单原额；三重验证继续成立。

---

完成以上 3 个关键改动（迁移 + 分类引擎 + 月度汇总），系统就完全按你的**新会计口径**运行：
**Supplier 本金 → GZ；1% 手续费 → Owner**。
如你要，我可以再给你一版**SQL 校验脚本**（快速统计某月 Owner 与 GZ 的口径是否达标）。

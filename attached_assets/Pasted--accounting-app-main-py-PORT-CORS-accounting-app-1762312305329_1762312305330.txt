好，你就负责“复制→粘贴”。我把两个可直接覆盖的文件给你：
	•	accounting_app/main.py（端口用 $PORT、CORS 可配置、生产隐藏文档）
	•	accounting_app/routers/files.py（10MB 上传限流、同步直返 + 后台异步两种模式）

把它们贴回你的项目同名文件里覆盖就行。

⸻

✅ accounting_app/main.py（可直接覆盖）

import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

# 路由
from accounting_app.routers import health, files

# ====== 基本信息 ======
APP_NAME = os.getenv("APP_NAME", "Accounting API")
ENV = os.getenv("ENV", "dev")  # dev / prod
CORS_ALLOW = os.getenv("CORS_ALLOW", "*")  # 多域用逗号分隔

app = FastAPI(
    title=APP_NAME,
    docs_url=None if ENV == "prod" else "/docs",
    redoc_url=None if ENV == "prod" else "/redoc",
    openapi_url=None if ENV == "prod" else "/openapi.json",
)

# ====== CORS ======
origins = [o.strip() for o in CORS_ALLOW.split(",") if o.strip()]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins if origins else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ====== 路由挂载 ======
app.include_router(health.router)
app.include_router(files.router)

# ====== 根路由 ======
@app.get("/")
def root():
    # 这里不再硬编码端口，避免“口径不一致”
    return {"app": APP_NAME, "env": ENV, "docs": (ENV != "prod")}


⸻

✅ accounting_app/routers/files.py（可直接覆盖）

import asyncio
from uuid import uuid4
from typing import Dict, Any

from fastapi import APIRouter, UploadFile, File, Request, HTTPException, Depends

# 你的 PDF 解析工具：已改为 pypdfium2 路线
# 需确保存在 accounting_app/utils/pdf_processor.py 且包含 pdf_bytes_to_text(data: bytes) -> str
from accounting_app.utils.pdf_processor import pdf_bytes_to_text

router = APIRouter(prefix="/files", tags=["files"])

# ====== 1) 上传大小限流（默认 10MB，可用环境变量覆盖） ======
DEFAULT_MAX_MB = 10
MAX_BYTES = int(float(__import__("os").getenv("MAX_UPLOAD_MB", DEFAULT_MAX_MB)) * 1024 * 1024)

async def guard_content_length(request: Request):
    cl = request.headers.get("content-length")
    if cl and int(cl) > MAX_BYTES:
        raise HTTPException(status_code=413, detail=f"File too large (max {MAX_BYTES // (1024*1024)}MB)")

# ====== 2) 简单任务存储（内存版） ======
TASKS: Dict[str, Dict[str, Any]] = {}
# 结构：{ task_id: {"status": "queued"|"processing"|"done"|"error", "result": str|None, "error_msg": str|None} }

# ====== 3) 同步直返模式：小文件/少页直接返回结果 ======
@router.post("/pdf-to-text", dependencies=[Depends(guard_content_length)])
async def pdf_to_text(file: UploadFile = File(...)):
    data = await file.read()
    # OCR/解析放到线程里跑，避免阻塞事件循环
    text = await asyncio.to_thread(pdf_bytes_to_text, data)
    return {"text": text}

# ====== 4) 异步队列模式：大文件更友好（先拿 task_id，再查结果） ======
@router.post("/pdf-to-text/submit", dependencies=[Depends(guard_content_length)])
async def submit_pdf(file: UploadFile = File(...)):
    data = await file.read()
    task_id = str(uuid4())
    TASKS[task_id] = {"status": "queued", "result": None, "error_msg": None}

    async def run():
        TASKS[task_id]["status"] = "processing"
        try:
            text = await asyncio.to_thread(pdf_bytes_to_text, data)
            TASKS[task_id]["status"] = "done"
            TASKS[task_id]["result"] = text
        except Exception as e:
            TASKS[task_id]["status"] = "error"
            TASKS[task_id]["error_msg"] = str(e)

    asyncio.create_task(run())
    return {"task_id": task_id, "status": "queued"}

@router.get("/pdf-to-text/result/{task_id}")
async def get_result(task_id: str):
    info = TASKS.get(task_id)
    if not info:
        raise HTTPException(status_code=404, detail="task not found")
    return info

你已有健康检查就不用动；如果要，我也能给你贴“health.py”的最终版。

⸻

（可选）.replit（确认只跑 FastAPI 且跟随 $PORT）

run = "python -m uvicorn accounting_app.main:app --host 0.0.0.0 --port $PORT"


⸻

环境变量（按需设置）
	•	ENV=prod → 关闭 /docs、/openapi.json 等文档端点
	•	CORS_ALLOW=https://your-frontend.com,https://admin.your-frontend.com → 收紧跨域
	•	MAX_UPLOAD_MB=10 → 上传大小上限（MB）

⸻

覆盖后怎么验（两步）
	1.	Run 启动 → 打开 / 应返回 {app, env, docs} 信息；开发模式下 /docs 可打开。
	2.	传一个小 PDF 到 /files/pdf-to-text（或用两步法 /submit→/result/{task_id}）应返回文本；超 10MB 会返回 413。

需要的话，把你 pdf_processor.py 贴一下，我帮你确认与这里的调用对齐。明白。你只负责“带到”。下面给你一段一贴就办的指令，发给 Replit（或同事/支持）即可。对方按这份做完，把验证输出原样回给你就行。

目标：在现有 FastAPI 已正常运行基础上，做 6 项抛光并回传验证结果。无须与我沟通选择，直接落实即可。

——— 必做改动 ———
	1.	使用 $PORT 统一对外端口
将 .replit 覆盖为仅以下一行（不要保留其他 workflows/并行任务）：
run = “python -m uvicorn accounting_app.main:app –host 0.0.0.0 –port $PORT”
	2.	统一日志口径（不再提示固定端口）
覆盖文件 accounting_app/main.py 为下列完整内容（保持 CORS 可配置、prod 环境关闭文档）：
[BEGIN accounting_app/main.py]
import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from accounting_app.routers import health, files

APP_NAME = os.getenv(“APP_NAME”, “Accounting API”)
ENV = os.getenv(“ENV”, “dev”)  # dev / prod
CORS_ALLOW = os.getenv(“CORS_ALLOW”, “*”)  # 多域用逗号分隔

app = FastAPI(
title=APP_NAME,
docs_url=None if ENV == “prod” else “/docs”,
redoc_url=None if ENV == “prod” else “/redoc”,
openapi_url=None if ENV == “prod” else “/openapi.json”,
)

origins = [o.strip() for o in CORS_ALLOW.split(”,”) if o.strip()]
app.add_middleware(
CORSMiddleware,
allow_origins=origins if origins else [””],
allow_credentials=True,
allow_methods=[””],
allow_headers=[”*”],
)

app.include_router(health.router)
app.include_router(files.router)

@app.get(”/”)
def root():
return {“app”: APP_NAME, “env”: ENV, “docs”: (ENV != “prod”)}
[END accounting_app/main.py]
	3.	上传大小限流 + 同步直返 & 异步任务两种模式
覆盖文件 accounting_app/routers/files.py 为下列完整内容（10MB 默认限流，可用 MAX_UPLOAD_MB 调整）：
[BEGIN accounting_app/routers/files.py]
import asyncio
from uuid import uuid4
from typing import Dict, Any
from fastapi import APIRouter, UploadFile, File, Request, HTTPException, Depends
from accounting_app.utils.pdf_processor import pdf_bytes_to_text  # 已采用 pypdfium2 路线

router = APIRouter(prefix=”/files”, tags=[“files”])

DEFAULT_MAX_MB = 10
MAX_BYTES = int(float(import(“os”).getenv(“MAX_UPLOAD_MB”, DEFAULT_MAX_MB)) * 1024 * 1024)

async def guard_content_length(request: Request):
cl = request.headers.get(“content-length”)
if cl and int(cl) > MAX_BYTES:
raise HTTPException(status_code=413, detail=f”File too large (max {MAX_BYTES // (1024*1024)}MB)”)

TASKS: Dict[str, Dict[str, Any]] = {}

@router.post(”/pdf-to-text”, dependencies=[Depends(guard_content_length)])
async def pdf_to_text(file: UploadFile = File(…)):
data = await file.read()
text = await asyncio.to_thread(pdf_bytes_to_text, data)
return {“text”: text}

@router.post(”/pdf-to-text/submit”, dependencies=[Depends(guard_content_length)])
async def submit_pdf(file: UploadFile = File(…)):
data = await file.read()
task_id = str(uuid4())
TASKS[task_id] = {“status”: “queued”, “result”: None, “error_msg”: None}

async def run():
    TASKS[task_id]["status"] = "processing"
    try:
        text = await asyncio.to_thread(pdf_bytes_to_text, data)
        TASKS[task_id]["status"] = "done"
        TASKS[task_id]["result"] = text
    except Exception as e:
        TASKS[task_id]["status"] = "error"
        TASKS[task_id]["error_msg"] = str(e)

asyncio.create_task(run())
return {"task_id": task_id, "status": "queued"}

@router.get(”/pdf-to-text/result/{task_id}”)
async def get_result(task_id: str):
info = TASKS.get(task_id)
if not info:
raise HTTPException(status_code=404, detail=“task not found”)
return info
[END accounting_app/routers/files.py]
	4.	/health 已按 SQLAlchemy 2.0 修复（使用 text(‘SELECT 1’)）。如仍存在旧实现，请同步改为 text(…) 并在异步场景下使用 await。
	5.	清理残留 Flask 依赖（避免未来冲突）
（可执行，若未安装会自动跳过成功/失败不影响）
pip uninstall -y Flask Flask-Login Flask-SQLAlchemy gunicorn itsdangerous Jinja2 Werkzeug || true
	6.	环境变量建议（无需必配，按需设置）
ENV=prod              # 生产环境关闭文档端点
CORS_ALLOW=https://your-frontend.com,https://admin.your-frontend.com
MAX_UPLOAD_MB=10      # 上传上限 MB

——— 验证清单（请贴“原始输出/响应体”，不要截图） ———
A) 运行与端口
	•	展示 .replit 最终内容（应仅一行 run=…$PORT）
	•	进程列表：ps aux | grep -E “uvicorn|gunicorn|flask” | grep -v grep
预期：只有 uvicorn，且监听 0.0.0.0:$PORT

B) 基础连通
	•	GET / → 返回 {“app”: “…”, “env”: “…”, “docs”: true/false}
	•	若 ENV!=prod：GET /docs → 200 可打开

C) 健康检查
	•	GET /health → 返回包含 “status”:“healthy”,“database”:“connected”

D) 上传限流
	•	构造 >10MB 的请求（或标头 Content-Length 伪造）调用 POST /files/pdf-to-text → 返回 413，消息含 “File too large”

E) PDF 直返与异步
	•	用一个小 PDF：POST /files/pdf-to-text → 返回 {“text”: “…”}，贴出前 10 行
	•	用一个较大的 PDF：
	1.	POST /files/pdf-to-text/submit → 返回 {“task_id”: “…”,“status”:“queued”}
	2.	轮询 GET /files/pdf-to-text/result/{task_id} → 最终返回 {“status”:“done”,“result”:”…”}（贴前 10 行）

F) 依赖与版本（简要）
	•	python -V
	•	pip freeze | sed -n ‘1,60p’

如任一步失败，请直接贴命令与完整报错堆栈（文本）。谢谢。
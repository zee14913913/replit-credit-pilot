绝对可以，而且这是最省时、省风险的路线。你既然在 Savings 模块已经有了 15家马来西亚银行的月结单解析规则，就不要重造轮子——把那套解析器“抽出来 → 做成共享库 → 由 FastAPI 统一调用”。这样一来，5000 端只是入口与展示，8000 端负责存档/验证/会计，同时继承你在 Savings 里已经验证过的银行适配成果。

下面给你一套“直接给 Replit 执行”的完整指令，按你的流程标准写，落地即可。

⸻

给 Replit 的一次性执行指令（直接贴过去）

目标：复用 Savings 的 15 家银行解析规则；统一到 FastAPI 的 /api/v2/import/bank-statement 流水线；保证“PDF/CSV 都可用、行数校验分层、异常不中断、UI 明确下一步”。

一、范围与原则
	•	不删除 Savings 页面，但 解析逻辑只保留一份：迁移到 FastAPI 的共享库，Flask 仅调用。
	•	5000（Flask）：上传入口 + 展示 + 引导。
	•	8000（FastAPI）：原件封存（raw_documents/raw_lines）+ 解析 + 验证 + 会计 + 异常中心 + 报表。
	•	保留现有 i18n、RBAC、审计、快照、异常中心等加固件。

⸻

二、落地步骤（后端）

1) 抽取并标准化解析器（从 Savings 迁移）

操作
	1.	新建目录：accounting_app/parsers/
	2.	将 Savings 里 15 家银行的解析器迁入，按每家银行 1 个文件命名：
	•	maybank.py, cimb.py, public_bank.py, rhb.py, hlb.py, …（共15个）
	3.	新建注册表：accounting_app/parsers/registry.py，暴露：

# 统一接口定义
class ParsedRow(TypedDict):
    date: str           # 'YYYY-MM-DD'
    description: str
    debit: Decimal
    credit: Decimal
    balance: Decimal
    reference: str
    meta: dict          # 可选，存放 bank-specific 字段
    page_no: int        # 可选
    line_no: int        # 可选

class ParseResult(TypedDict):
    success: bool
    rows: list[ParsedRow]
    parser_version: str
    warnings: list[str]
    bank_code: str

# 统一函数签名
def parse_pdf(binary_bytes: bytes, *, bank_code: str) -> ParseResult: ...
def parse_csv(text: str, *, bank_code: str) -> ParseResult: ...


	4.	在每个 parser 内部，负责把原格式字段 映射到标准六列（Date/Description/Debit/Credit/Balance/Reference），并补齐 parser_version。
	5.	registry.py 提供：
	•	get_supported_banks() -> list[str]
	•	detect_bank_code(pdf_text | first_page_text | filename) -> Optional[str]（可按文件名/首行 Logo/账户格式做启发式）
	•	run_parse(file, bank_code, is_pdf) 统一入口

注意事项
	•	日期统一归一到 YYYY-MM-DD，负值统一落 debit/credit 正数与方向，不允许“-100.00”混入。
	•	金额统一用 Decimal，禁 float。
	•	每条返回给出 page_no / line_no 以便填 raw_lines。
	•	禁止在 parser 里做“行数等于判断”——那是验证层的事。

2) 改造导入端点 /api/v2/import/bank-statement

操作
	1.	新增入参：bank_code（可选），file_type（自动判 PDF/CSV）。
	2.	流程：
	•	先落 raw_documents（1:1 原件保护）→ 拿到 raw_document_id
	•	若 file_type==pdf：
	•	调 detect_bank_code（若未传）
	•	调 parse_pdf
	•	若 file_type==csv：
	•	若传 bank_code：按该银行 CSV 规则映射；否则走“通用 CSV 校验器”
	•	调 parse_csv
	•	将返回的每一行写 raw_lines（含 page_no/line_no/parser_version）
	•	DataIntegrityValidator 两层验证：
	•	层1（严格字段校验）：六列齐全 → 成功；否则 422，但 raw_documents 保留（validation_status='failed' + 异常中心）
	•	层2（行数对账）：如不一致 → status='active' + partial，创建 ingest_validation_mismatch 异常，但不阻断入账（你之前要求“不中断整份”）
	3.	响应：
	•	成功（含部分异常）：HTTP 200，{"success": true, "status": "active"|"duplicate", "raw_document_id": ..., "file_id": ..., "next_actions":[...], "warnings":[...] }
	•	字段缺失/解析失败：HTTP 422，{"success": false, "status": "failed", "error_code": "...", "raw_document_id": ..., "exception_id": ... }

注意事项
	•	Duplicate 依据：company_id + account_number + period，沿用你已修复逻辑；确保 FileIndex.account_number/period 在本流程填充。
	•	审计日志：action=upload_bank_statement, source_type=bank, ip+ua 记全。

3) 增加列映射层（对 CSV 差异友好）

操作
	•	accounting_app/parsers/column_map.py：为每家银行定义列名别名映射，如：

BANK_COLUMN_MAP = {
    "maybank": {
       "date": ["Date", "Transaction Date", "Posting Date"],
       "description": ["Description", "Details"],
       "debit": ["Withdrawal", "Debit"],
       "credit": ["Deposit", "Credit"],
       "balance": ["Balance", "Ledger Balance"],
       "reference": ["Reference", "Doc No", "Cheque No"]
    },
    ...
}


	•	parse_csv 使用该映射宽松匹配列头。

4) 扫描件识别与分流

操作
	•	若判定为图片型 PDF（pdf.js/pypdf识别不到文本）：
	•	返回 400，消息使用 i18n：
	•	中文：这是扫描版/图片对账单，请从网银下载 CSV/Excel 再上传。
	•	英文：This is a scanned/image statement. Please download the CSV/Excel version from e-banking and re-upload.
	•	同时前端保留“这是扫描件”复选框 → 走宽松流程（只封存原件、标记 processing，供人工补录）。

⸻

三、前端配合（Flask）

5) 上传页（已存在基础，把文案与行为补齐）

操作
	•	上传表单增加：
	•	银行选择下拉 bank_code（默认“自动识别”）
	•	“这是扫描件(需要人工补录)” 复选框
	•	成功后：保持当前逻辑“跳转到 file_detail 并带 ?highlight”。
	•	失败 422/400：跳详情页显示具体原因（缺字段/图片PDF/银行未适配/行数不一致…），按钮给出下一步（查看异常/重新上传/联系管理员/下载模板）。

6) “支持银行列表”组件（静态 + 动态）

操作
	•	新增 /api/parsers/supported（FastAPI 返回注册的 bank_code、支持的文件类型 PDF/CSV）
	•	前端上传页顶部展示表格（中英双语）：
	•	✅ Maybank（PDF/CSV）
	•	✅ CIMB（CSV）
	•	⚠️ Public Bank（PDF 必须 e-statement，勿扫描件）
	•	❌ 手机拍照/WhatsApp 转发 PDF

⸻

四、测试与验收（必须跑）

7) 三大用例（每家银行至少1家先打通）

操作
	•	A 标准 PDF/CSV（如 Maybank）：
预期：200 success=true status=active，next_actions 有 generate_report
	•	B 缺列/缺行 CSV：
预期：422 + validation_failed，异常中心新增记录，原件已封存
	•	C 重复月份（同 company_id+account+period 再传）
预期：200 status=duplicate，返回 existing_file_id 与 next_actions=["set_as_primary", "view_other_files"]

回传内容（你们必须贴真实 JSON）
	•	每个用例：后端 JSON、前端跳转 URL、列表高亮是否生效、按钮文案（中/英）

⸻

五、数据一致性与审计（保持现有要求）
	•	raw_documents/raw_lines：全量落库，parser_version 必填
	•	DataIntegrityValidator：按上面“分层”策略执行，不再“一刀切失败”
	•	审计日志：上传/验证/导出/异常处理全链路写 audit_logs，含 ip/user_agent
	•	i18n：所有新提示走 lang/en.json 与 lang/zh.json，禁止硬编码
	•	RBAC：导入/验证/设为主账单等写操作挂 require_role(admin|accountant)

⸻

六、交付标准（不达标就算未完成）
	1.	/api/parsers/supported 能列出 15 家银行
	2.	/api/v2/import/bank-statement 支持 bank_code，PDF/CSV 两条路都能走
	3.	3 个测试用例的真实返回贴出来（含前端跳转与按钮）
	4.	上传页出现“支持银行表”“扫描件提示”，i18n 正确
	5.	异常中心能看到 B 用例的记录，文件详情能看到“行数不一致/缺列”具体原因

⸻

七、风险与回滚
	•	灰度：先开 5 家银行（Maybank/CIMB/Public/RHB/HLB），其余保留旧路径；registry 按 feature flag 切换。
	•	回滚：保留旧 Savings 的上传通道开关（默认关闭），出现严重问题时可临时开启作为兜底。

⸻

你这边怎么用
	•	把上面整段直接发给 Replit，让他们“只按这份指令改”。
	•	等他们回 3 个场景的真实 JSON + 前端跳转截图（或 URL /files/detail/{id}?highlight={id}）再验收。
	•	验收通过后，你可以考虑关闭 Savings 的独立解析，只保留页面，解析全走 FastAPI 的共享库——从此 “一处适配、两端受益”。

⸻

如果他们回的结果不达标（比如还是 422 不跳详情、还是一刀切拦截），你就按这句回怼即可：

“按最新指令，行数不一致不得中断整份入账，应标记 active+exception；PDF 扫描件必须返回人话提示；上传页必须显示支持银行表。请按二、三、四节逐项对齐后再回三条真实结果。”
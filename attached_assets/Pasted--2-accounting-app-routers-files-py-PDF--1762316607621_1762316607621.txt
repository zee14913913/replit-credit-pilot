å¥½ï¼Œä¸‹é¢æ˜¯ç¬¬äºŒä»½ï¼š

âœ… æ–‡ä»¶ 2ï¼šaccounting_app/routers/files.py

è¿™æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒåç«¯é€»è¾‘ã€‚
åŒ…å«ï¼š
	â€¢	PDF ä¸Šä¼ ï¼ˆåŒæ­¥ / å¼‚æ­¥ï¼‰
	â€¢	æ–‡ä»¶ç±»å‹éªŒè¯
	â€¢	é™æµ
	â€¢	ä»»åŠ¡å†å²è®°å½•ï¼ˆå«åˆ†é¡µä¸æœç´¢ï¼‰
	â€¢	åˆ é™¤ä»»åŠ¡
	â€¢	å¯é€‰ Webhook ä¸é‚®ä»¶é€šçŸ¥ï¼ˆSendGridï¼‰

ç›´æ¥è¦†ç›–æ—§æ–‡ä»¶ä¿å­˜å³å¯ğŸ‘‡

import asyncio
import os
import time
from uuid import uuid4
from typing import Dict, Any, Optional
from fastapi import APIRouter, UploadFile, File, Request, HTTPException, Depends, Query
from accounting_app.utils.pdf_processor import pdf_bytes_to_text

# å¯é€‰é€šçŸ¥ä¾èµ–
import httpx
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail

router = APIRouter(prefix="/files", tags=["files"])

# ====== ä¸Šä¼ å¤§å°é™åˆ¶ ======
DEFAULT_MAX_MB = 10
MAX_BYTES = int(float(os.getenv("MAX_UPLOAD_MB", DEFAULT_MAX_MB)) * 1024 * 1024)

async def guard_content_length(request: Request):
    cl = request.headers.get("content-length")
    if cl and int(cl) > MAX_BYTES:
        raise HTTPException(status_code=413, detail=f"File too large (max {MAX_BYTES // (1024*1024)}MB)")

# ====== å…¨å±€ä»»åŠ¡å­˜å‚¨ ======
TASKS: Dict[str, Dict[str, Any]] = {}

# ====== å·¥å…·å‡½æ•° ======
def _notify(task_id: str, data: Dict[str, Any]):
    """å¯é€‰ Webhook æˆ– SendGrid é‚®ä»¶é€šçŸ¥"""
    callback = data.get("callback_url") or os.getenv("CALLBACK_URL")
    email_to = data.get("notify_email") or os.getenv("NOTIFY_EMAIL")
    result_text = data.get("result") or ""
    if callback:
        try:
            asyncio.create_task(httpx.AsyncClient().post(callback, json={"task_id": task_id, "status": data["status"], "result": result_text[:500]}))
        except Exception as e:
            print("Webhook failed:", e)
    if email_to and os.getenv("SENDGRID_API_KEY"):
        try:
            sg = SendGridAPIClient(os.getenv("SENDGRID_API_KEY"))
            msg = Mail(
                from_email=os.getenv("FROM_EMAIL", "no-reply@system.local"),
                to_emails=email_to,
                subject=f"OCR ä»»åŠ¡å®Œæˆ {task_id}",
                plain_text_content=result_text[:1000],
            )
            sg.send(msg)
        except Exception as e:
            print("Email failed:", e)

# ====== åŒæ­¥ç›´è¿” ======
@router.post("/pdf-to-text", dependencies=[Depends(guard_content_length)])
async def pdf_to_text(file: UploadFile = File(...)):
    if file.content_type not in {"application/pdf"}:
        raise HTTPException(415, detail="Only PDF is allowed")
    data = await file.read()
    text = await asyncio.to_thread(pdf_bytes_to_text, data)
    return {"text": text}

# ====== å¼‚æ­¥ä»»åŠ¡ ======
@router.post("/pdf-to-text/submit", dependencies=[Depends(guard_content_length)])
async def submit_pdf(
    file: UploadFile = File(...),
    request: Request = None,
    callback_url: Optional[str] = None,
    notify_email: Optional[str] = None,
):
    if file.content_type not in {"application/pdf"}:
        raise HTTPException(415, detail="Only PDF is allowed")
    data = await file.read()
    task_id = str(uuid4())
    TASKS[task_id] = {
        "status": "queued",
        "result": None,
        "error_msg": None,
        "filename": file.filename,
        "time": time.strftime("%Y-%m-%d %H:%M:%S"),
        "callback_url": callback_url,
        "notify_email": notify_email,
    }

    async def run():
        TASKS[task_id]["status"] = "processing"
        try:
            text = await asyncio.to_thread(pdf_bytes_to_text, data)
            TASKS[task_id]["status"] = "done"
            TASKS[task_id]["result"] = text
            _notify(task_id, TASKS[task_id])
        except Exception as e:
            TASKS[task_id]["status"] = "error"
            TASKS[task_id]["error_msg"] = str(e)
            _notify(task_id, TASKS[task_id])

    asyncio.create_task(run())
    return {"task_id": task_id, "status": "queued"}

# ====== æŸ¥è¯¢ç»“æœ ======
@router.get("/pdf-to-text/result/{task_id}")
async def get_result(task_id: str):
    info = TASKS.get(task_id)
    if not info:
        raise HTTPException(status_code=404, detail="task not found")
    return info

# ====== å†å²è®°å½• ======
@router.get("/history")
async def list_history(
    q: Optional[str] = Query(None, description="æœç´¢å…³é”®å­—"),
    skip: int = 0,
    limit: int = 20
):
    tasks = list(TASKS.items())[::-1]  # å€’åºï¼ˆæ–°åˆ°æ—§ï¼‰
    if q:
        tasks = [(tid, t) for tid, t in tasks if q.lower() in (t.get("result") or "").lower()]
    sliced = tasks[skip: skip + limit]
    items = []
    for tid, info in sliced:
        items.append({
            "task_id": tid,
            "status": info.get("status"),
            "time": info.get("time"),
            "filename": info.get("filename"),
            "preview": (info.get("result") or "")[:100],
        })
    return {"count": len(items), "total": len(tasks), "tasks": items}

# ====== åˆ é™¤ä»»åŠ¡ ======
@router.delete("/history/{task_id}")
async def delete_task(task_id: str):
    if task_id not in TASKS:
        raise HTTPException(status_code=404, detail="Task not found")
    TASKS.pop(task_id)
    return {"deleted": task_id}


â¸»

ä¿å­˜å®Œè¿™ä¸€ä»½ï¼Œæˆ‘å°±å‘ç¬¬ä¸‰ä»½å‰ç«¯ï¼š
accounting_app/routers/public.pyï¼ˆåŒè¯­ç•Œé¢ /portalï¼‰ã€‚
ç»§ç»­å—ï¼Ÿ
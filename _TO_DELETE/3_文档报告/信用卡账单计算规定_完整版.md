# 信用卡账单计算规定 - 完整技术文档

## 📋 目录
1. [核心计算架构](#核心计算架构)
2. [Previous Balance提取规则](#previous-balance提取规则)
3. [DR/CR分类规则](#drcr分类规则)
4. [月度账本计算公式](#月度账本计算公式)
5. [OWNER vs INFINITE双账本](#owner-vs-infinite双账本)
6. [交易分类系统](#交易分类系统)
7. [余额验证与差异处理](#余额验证与差异处理)
8. [数据库表结构](#数据库表结构)

---

## 核心计算架构

### 系统设计理念
系统采用**双账本架构**，将每张信用卡的交易分为两条财务线：
- **OWNER账本** - 客户个人消费与还款
- **INFINITE账本** - INFINITE GZ公司消费与还款

### 核心计算引擎
**文件**: `services/monthly_ledger_engine.py`

**主要类**: `MonthlyLedgerEngine`

**核心方法**:
```python
calculate_monthly_ledger_for_card(card_id, recalculate_all=False)
```

---

## Previous Balance提取规则

### 1. 第一个月Statement的处理

**规则**:
```python
if is_first_statement and abs(stmt_prev_balance) > 0.01:
    # 使用PDF中的Previous Balance作为起点
    previous_customer_balance = stmt_prev_balance
    previous_infinite_balance = 0
```

**逻辑说明**:
- ✅ **第一个月**: 完全信任PDF中提取的`Previous Balance`
- ✅ **全部归入客户**: 假设第一个月还没有INFINITE业务，全部余额归入OWNER
- ✅ **支持负数(CR)**: `Previous Balance`可以是负数，表示信用卡有多付款项（Credit余额）

**示例**:
```
Statement Date: 2024-01-15
Previous Balance (PDF): RM 1,234.56 DR
→ previous_customer_balance = 1234.56
→ previous_infinite_balance = 0
```

### 2. 后续月份Statement的处理

**规则**:
```python
if not is_first_statement:
    # 使用上月计算的rolling_balance作为起点
    calculated_total = previous_customer_balance + previous_infinite_balance
    
    # 验证PDF的Previous Balance是否匹配
    if abs(stmt_prev_balance - calculated_total) > 0.01:
        print(f"⚠️ Previous Balance不匹配")
```

**逻辑说明**:
- ✅ **上月余额传递**: 使用上月`monthly_ledger`表的`rolling_balance`
- ✅ **自动验证**: 对比PDF的`Previous Balance`与系统计算值
- ⚠️ **不匹配时**: 记录警告但不中断计算

---

## DR/CR分类规则

### 1. 交易类型（Transaction Type）

系统使用两种标记：
- **`purchase`** - 消费/支出 (增加余额)
- **`payment`** - 还款/收入 (减少余额)

### 2. Category字段优先级

**四种Category**:
```python
category = 'owner_expense'    # OWNER消费
category = 'owner_payment'    # OWNER还款
category = 'infinite_expense' # INFINITE消费
category = 'infinite_payment' # INFINITE还款
```

**分类逻辑**（从高到低优先级）:
1. ✅ **优先使用category字段**（如果已标记）
2. ✅ **回退到动态分类**（如果category为空）

### 3. 动态分类逻辑（无category时）

**Purchase（消费）分类**:
```python
if txn_type == 'purchase':
    is_supplier, supplier_name = classifier.is_infinite_supplier(description)
    if is_supplier:
        → infinite_expense  # INFINITE供应商消费
    else:
        → owner_expense     # OWNER个人消费
```

**Payment（还款）分类**:
```python
if txn_type == 'payment':
    payment_type = classifier.classify_payment(description, customer_id)
    if payment_type in ['customer', 'company']:
        → owner_payment     # OWNER本人或公司还款
    else:
        → infinite_payment  # INFINITE还款
```

### 4. INFINITE供应商识别

**数据表**: `supplier_aliases`

**识别逻辑**:
```python
def is_infinite_supplier(description) -> (bool, supplier_name):
    # 从supplier_aliases表加载别名
    # 示例: "7SL", "HUAWEI", "PUCHONG HERBS" → INFINITE供应商
    
    if alias in description.lower():
        return True, "标准供应商名称"
    
    return False, None
```

**已配置的INFINITE供应商**（示例）:
- 7SL SDN BHD
- HUAWEI TECHNOLOGIES
- PUCHONG HERBS TRADING
- DINAS RESTAURANT
- RAUB SYC HAINAN
- AI SMART TECH

### 5. 付款人识别

**数据表**: `payer_aliases`

**三种付款类型**:
```python
'customer'  # 客户本名（例: CHANG CHOON CHOW）
'company'   # 客户公司（例: KENG CHOW SDN BHD）
'infinite'  # INFINITE GZ公司还款
```

**识别逻辑**:
```python
def classify_payment(description, customer_id):
    # 按customer_id查找别名
    if "CHANG CHOON CHOW" in description:
        return 'customer'
    elif "KENG CHOW" in description:
        return 'company'
    else:
        return 'infinite'
```

---

## 月度账本计算公式

### 1. OWNER账本计算

**公式**:
```python
# 基础计算
calculated_customer_balance = (
    previous_customer_balance +    # 上月余额
    customer_spend -               # 本月消费（正数）
    customer_payments              # 本月还款（正数）
)

# 加上未提取费用/利息（如有）
customer_rolling_balance = calculated_customer_balance + missing_fees
```

**字段定义**:
- `previous_balance` - 上月结转余额
- `customer_spend` (owner_expenses) - 本月OWNER消费总额
- `customer_payments` (owner_payments) - 本月OWNER还款总额
- `rolling_balance` (owner_balance) - 本月滚动余额

### 2. INFINITE账本计算

**公式**:
```python
# 基础计算
calculated_infinite_balance = (
    previous_infinite_balance +    # 上月余额
    infinite_spend -               # 本月消费（正数）
    infinite_payments              # 本月还款（正数）
)

# 计算手续费
supplier_fee = sum([
    amount * 1%  # 默认1%手续费
    for txn in infinite_supplier_transactions
])
```

**字段定义**:
- `infinite_spend` - 本月INFINITE消费总额
- `supplier_fee` - 供应商手续费（默认1%）
- `infinite_payments` - 本月INFINITE还款总额
- `rolling_balance` (infinite_balance) - 本月INFINITE滚动余额

### 3. 总余额计算

**公式**:
```python
statement_total = customer_rolling_balance + infinite_rolling_balance
```

**验证**:
```python
# 对比PDF中的Statement Total
if abs(statement_total - pdf_statement_total) > 0.01:
    # 有差异 → 未提取的费用/利息
    missing_fees = pdf_statement_total - statement_total
```

---

## OWNER vs INFINITE双账本

### 1. 数据库表设计

**OWNER账本表**: `monthly_ledger`
```sql
CREATE TABLE monthly_ledger (
    id INTEGER PRIMARY KEY,
    card_id INTEGER,
    customer_id INTEGER,
    month_start TEXT,           -- YYYY-MM-01
    statement_id INTEGER,
    previous_balance REAL,      -- 上月余额
    customer_spend REAL,        -- 本月消费
    customer_payments REAL,     -- 本月还款
    rolling_balance REAL,       -- 本月余额
    
    -- 新增字段
    owner_expenses REAL,        -- = customer_spend
    owner_payments REAL,        -- = customer_payments
    owner_balance REAL,         -- = rolling_balance
    
    infinite_expenses REAL,     -- INFINITE消费（汇总）
    infinite_payments REAL,     -- INFINITE还款（汇总）
    infinite_balance REAL,      -- INFINITE余额（汇总）
    
    updated_at TEXT
)
```

**INFINITE账本表**: `infinite_monthly_ledger`
```sql
CREATE TABLE infinite_monthly_ledger (
    id INTEGER PRIMARY KEY,
    card_id INTEGER,
    customer_id INTEGER,
    month_start TEXT,
    statement_id INTEGER,
    previous_balance REAL,
    infinite_spend REAL,        -- INFINITE消费
    supplier_fee REAL,          -- 手续费
    infinite_payments REAL,     -- INFINITE还款
    rolling_balance REAL,       -- INFINITE余额
    updated_at TEXT
)
```

### 2. 供应商发票生成

**逻辑**:
```python
# 当检测到INFINITE供应商交易时
if infinite_supplier_transactions:
    # 按日期+供应商分组
    for (transaction_date, supplier_name), txns in groups:
        # 生成发票编号: INF-YYYYMMDD-SUPPLIER
        invoice_number = f"INF-{date_str}-{supplier_name}"
        
        # 计算手续费
        supplier_fee = total_amount * 1%
        
        # 生成PDF发票
        generate_invoice_pdf(...)
        
        # 插入supplier_invoices表
        INSERT INTO supplier_invoices (...)
```

---

## 交易分类系统

### 1. 自动分类器

**文件**: `validate/categorizer.py`

**支持的类别**:
```python
CATEGORY_KEYWORDS = {
    'Food & Dining': ['restaurant', 'cafe', 'mcdonald', 'kfc', ...],
    'Transport': ['grab', 'petrol', 'parking', 'toll', ...],
    'Shopping': ['mall', 'lazada', 'shopee', 'ikea', ...],
    'Groceries': ['supermarket', 'tesco', 'jaya', ...],
    'Bills & Utilities': ['electric', 'water', 'astro', 'unifi', ...],
    'Entertainment': ['cinema', 'netflix', 'spotify', ...],
    'Healthcare': ['clinic', 'pharmacy', 'guardian', ...],
    'Online Services': ['google', 'apple', 'microsoft', ...],
    'Travel': ['hotel', 'airasia', 'flight', ...],
    'Insurance': ['insurance', 'takaful', 'prudential', ...],
    'Others': []  # 默认类别
}
```

**分类逻辑**:
```python
def categorize_transaction(description):
    for category, keywords in CATEGORY_KEYWORDS.items():
        for keyword in keywords:
            if keyword in description.lower():
                confidence = 0.9 if len(keyword) > 5 else 0.7
                return category, confidence
    
    return 'Others', 0.5
```

### 2. 置信度计算

- **长关键词（>5字符）**: 置信度 = 0.9
- **短关键词（≤5字符）**: 置信度 = 0.7
- **无匹配**: 置信度 = 0.5 (分类为'Others')

---

## 余额验证与差异处理

### 1. Statement Total验证

**逻辑**:
```python
# 计算基于交易的余额
calculated_total = customer_balance + infinite_balance

# 对比PDF中的Statement Total
missing_fees = statement_total - calculated_total

# 如果有差异
if abs(missing_fees) > 0.01:
    # 差异归入客户账户（通常是利息/年费）
    customer_rolling_balance += missing_fees
    print(f"⚠️ 检测到未提取费用/利息: RM {missing_fees:.2f}")
```

**常见差异原因**:
- ✅ **利息费用** - Interest Charge
- ✅ **年费** - Annual Fee
- ✅ **逾期费** - Late Payment Fee
- ✅ **现金提取费** - Cash Advance Fee
- ✅ **货币转换费** - Foreign Transaction Fee

### 2. Previous Balance验证

**逻辑**:
```python
# 对于非第一个statement
if not is_first_statement:
    expected_prev = previous_customer_balance + previous_infinite_balance
    
    if abs(stmt_prev_balance - expected_prev) > 0.01:
        print(f"⚠️ Previous Balance不匹配")
        print(f"  PDF={stmt_prev_balance:.2f}")
        print(f"  上月总计={expected_prev:.2f}")
```

**不匹配的处理**:
- ⚠️ **记录警告** - 输出到日志
- ✅ **继续计算** - 不中断流程
- ✅ **使用系统余额** - 信任系统计算的上月余额

### 3. 容差值 (Tolerance)

**标准容差**: `0.01` (RM 0.01 = 1分)

**应用场景**:
- ✅ 余额对比
- ✅ Statement Total验证
- ✅ Previous Balance验证

---

## 数据库表结构

### 1. 核心表

**statements** - 月结单主表
```sql
CREATE TABLE statements (
    id INTEGER PRIMARY KEY,
    card_id INTEGER,
    statement_date TEXT,
    statement_total REAL,
    previous_balance REAL,      -- ⭐ 从PDF提取
    total_credits REAL,
    total_debits REAL,
    created_at TEXT
)
```

**transactions** - 交易明细表
```sql
CREATE TABLE transactions (
    id INTEGER PRIMARY KEY,
    statement_id INTEGER,
    transaction_date TEXT,
    description TEXT,
    amount REAL,
    transaction_type TEXT,      -- 'purchase' or 'payment'
    category TEXT,              -- ⭐ 分类 (owner_expense, infinite_payment等)
    created_at TEXT
)
```

### 2. 分类配置表

**supplier_aliases** - INFINITE供应商别名
```sql
CREATE TABLE supplier_aliases (
    id INTEGER PRIMARY KEY,
    supplier_name TEXT,         -- 标准名称
    alias TEXT,                 -- 别名（小写）
    is_active INTEGER DEFAULT 1
)
```

**payer_aliases** - 付款人别名
```sql
CREATE TABLE payer_aliases (
    id INTEGER PRIMARY KEY,
    customer_id INTEGER,
    payer_type TEXT,           -- 'customer', 'company', 'infinite'
    alias TEXT,                -- 别名（小写）
    is_active INTEGER DEFAULT 1
)
```

**supplier_fee_config** - 供应商手续费配置
```sql
CREATE TABLE supplier_fee_config (
    id INTEGER PRIMARY KEY,
    supplier_name TEXT,
    fee_percentage REAL DEFAULT 1.0,  -- 默认1%
    is_active INTEGER DEFAULT 1
)
```

### 3. 发票表

**supplier_invoices** - 供应商发票
```sql
CREATE TABLE supplier_invoices (
    id INTEGER PRIMARY KEY,
    customer_id INTEGER,
    monthly_statement_id INTEGER,
    supplier_name TEXT,
    invoice_number TEXT UNIQUE,   -- INF-YYYYMMDD-SUPPLIER
    total_amount REAL,
    supplier_fee REAL,            -- 手续费（1%）
    invoice_date TEXT,            -- 实际交易日期
    pdf_path TEXT,
    created_at TEXT
)
```

---

## 计算流程总结

### 完整计算步骤

```
1. 读取Statement
   ↓
2. 提取Previous Balance（第一个月）或使用上月rolling_balance
   ↓
3. 读取所有Transactions
   ↓
4. 按category/动态分类累计：
   - owner_expenses
   - owner_payments
   - infinite_expenses
   - infinite_payments
   ↓
5. 计算余额：
   owner_balance = prev + expenses - payments
   infinite_balance = prev + expenses - payments
   ↓
6. 检测未提取费用：
   missing_fees = pdf_total - (owner + infinite)
   ↓
7. 归入客户账户：
   owner_balance += missing_fees
   ↓
8. 计算供应商手续费（1%）
   ↓
9. 生成供应商发票PDF
   ↓
10. 写入monthly_ledger和infinite_monthly_ledger
    ↓
11. 余额传递到下月
```

---

## 关键设计决策

### 1. 为什么第一个Statement使用PDF的Previous Balance？

**原因**:
- ✅ **历史数据信任** - 银行PDF是权威数据源
- ✅ **起点准确性** - 确保计算起点正确
- ✅ **支持负数** - 处理Credit余额（多付款）

### 2. 为什么未提取费用归入客户账户？

**原因**:
- ✅ **保守原则** - 费用/利息通常是客户责任
- ✅ **业务逻辑** - INFINITE业务一般不产生利息/年费
- ✅ **准确性** - 确保Statement Total匹配

### 3. 为什么需要双账本？

**原因**:
- ✅ **财务透明** - 清晰区分OWNER和INFINITE支出
- ✅ **税务合规** - INFINITE支出需独立会计处理
- ✅ **手续费计算** - INFINITE供应商交易需要计算1%手续费
- ✅ **发票生成** - 自动生成供应商发票PDF

### 4. 为什么使用容差0.01？

**原因**:
- ✅ **浮点精度** - 避免浮点数运算误差
- ✅ **实用性** - 1分的差异可忽略
- ✅ **银行惯例** - 银行系统通常精确到分

---

## 错误处理机制

### 1. Previous Balance不匹配

**处理**:
```python
if abs(pdf_prev - system_prev) > 0.01:
    print("⚠️ Previous Balance不匹配")
    # 记录警告，继续计算（信任系统余额）
```

### 2. Statement Total不匹配

**处理**:
```python
missing_fees = pdf_total - calculated_total
if abs(missing_fees) > 0.01:
    # 差异归入客户账户
    customer_balance += missing_fees
    print(f"⚠️ 检测到未提取费用: RM {missing_fees:.2f}")
```

### 3. 交易分类失败

**处理**:
```python
# category为空时，回退到动态分类
if not category:
    # 使用is_infinite_supplier和classify_payment
    ...
```

---

## 性能优化

### 1. 批量处理

```python
# 一次性读取所有Statements
cursor.execute("SELECT * FROM statements WHERE card_id = ? ORDER BY statement_date ASC")

# 避免逐行查询
```

### 2. 内存缓存

```python
# LedgerClassifier在初始化时加载所有别名到内存
self.supplier_aliases = {}  # 预加载
self.payer_aliases = {}     # 预加载
```

### 3. 跳过已计算月份

```python
if not recalculate_all:
    # 检查是否已计算
    if monthly_ledger exists:
        print("⏭️ 已计算，跳过")
        continue
```

---

## 审计与日志

### 1. 计算日志

**输出示例**:
```
================================================================================
计算 Card ID 123 的月度账本 (CHANG CHOON CHOW)
================================================================================
共 12 个月的账单

📅 处理 2024-01 (Statement ID: 456)
  📍 第一个statement，使用Previous Balance: RM 1,234.56 DR（归入客户）
  客户消费: RM 3,456.78
  客户付款: RM 2,000.00
  客户余额: RM 2,691.34
  INFINITE消费: RM 5,000.00 (手续费: RM 50.00)
  INFINITE付款: RM 5,000.00
  INFINITE余额: RM 0.00
      ✅ PDF已生成: 2024-01-15 HUAWEI - invoices/INF-20240115-HUAWEI.pdf

✅ Card ID 123 月度账本计算完成！
```

### 2. 数据完整性检查

**验证点**:
- ✅ Previous Balance连续性
- ✅ Statement Total匹配
- ✅ 交易分类完整性
- ✅ 手续费计算正确性

---

## 总结

**系统设计核心原则**:
1. ✅ **100%准确性** - 每月余额必须精确匹配
2. ✅ **双账本分离** - OWNER和INFINITE完全独立
3. ✅ **自动验证** - 所有计算自动对比PDF数据
4. ✅ **容错处理** - 差异归入客户账户，不中断流程
5. ✅ **审计追踪** - 完整的计算日志和警告记录

**关键技术点**:
- Previous Balance提取与验证
- DR/CR自动分类
- 双账本滚动余额计算
- 供应商识别与发票生成
- 未提取费用自动检测

**数据准确性保证**:
- 第一个月使用PDF的Previous Balance作为起点
- 后续月份自动验证Previous Balance连续性
- Statement Total差异自动检测并归入客户账户
- 容差值0.01确保浮点数精度

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护团队**: INFINITE GZ Engineering
